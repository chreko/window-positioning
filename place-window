#!/usr/bin/env bash
# place-window: Position windows in dom0 with mouse selection or window ID
# Usage:
#   place-window                  # Interactive mode
#   place-window ul|ur|ll|lr|c    # Quick presets
#   place-window <X> <Y> <W> <H>  # Custom geometry
#   place-window ws <N>           # Move to workspace N (0-based)
#   place-window save <name>      # Save current window position
#   place-window load <name>      # Load saved position

set -euo pipefail

CONFIG_DIR="${HOME}/.config/window-positioning"
PRESETS_FILE="${CONFIG_DIR}/presets.conf"
SETTINGS_FILE="${CONFIG_DIR}/settings.conf"
WORKSPACE_STATE_FILE="${CONFIG_DIR}/workspace-state.conf"

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# Initialize settings file if not exists
if [[ ! -f "$SETTINGS_FILE" ]]; then
    cat > "$SETTINGS_FILE" << 'EOF'
# Window positioning settings
# Gap around windows (in pixels)
GAP=10

# Panel height (adjust for your XFCE theme)
# Set to 0 if panel auto-hides or doesn't reserve space
PANEL_HEIGHT=30

# Panel auto-hide mode
# Set to true if panel is set to auto-hide (intelligently or always)
# When true, panel height is ignored for layout calculations
PANEL_AUTOHIDE=false

# Minimum window size
MIN_WIDTH=400
MIN_HEIGHT=300

# Auto-layout preferences
# Available layouts for each window count:
# 1 window: maximize
# 2 windows: equal, primary-secondary, secondary-primary
# 3 windows: main-two-side, three-columns, center-sidebars
# 4 windows: grid, main-three-side, three-top-bottom
# 5 windows: center-corners, two-three-columns, grid-wide-bottom

AUTO_LAYOUT_1="maximize"
AUTO_LAYOUT_2="equal"
AUTO_LAYOUT_3="main-two-side"
AUTO_LAYOUT_4="grid"
AUTO_LAYOUT_5="grid-wide-bottom"

# Window decoration dimensions (in pixels)
# Height: title bar height - set to 0 if windows don't have title bars
DECORATION_HEIGHT=24

# Width: side border width (left + right combined) - usually 0 for modern themes  
DECORATION_WIDTH=0
EOF
fi

# Initialize presets file if not exists
if [[ ! -f "$PRESETS_FILE" ]]; then
    cat > "$PRESETS_FILE" << 'EOF'
# Window positioning presets
# Format: NAME=X,Y,WIDTH,HEIGHT
# You can add custom presets here
browser-left=10,40,960,1040
browser-right=970,40,960,1040
terminal-top=10,40,1920,500
terminal-bottom=10,580,1920,500
editor-center=480,270,960,540
EOF
fi

# Load settings
source "$SETTINGS_FILE"

# Set defaults if not in config
GAP=${GAP:-10}
PANEL_HEIGHT=${PANEL_HEIGHT:-30}
PANEL_AUTOHIDE=${PANEL_AUTOHIDE:-false}
MIN_WIDTH=${MIN_WIDTH:-400}
MIN_HEIGHT=${MIN_HEIGHT:-300}

# Window decoration dimensions - configurable via settings
DECORATION_HEIGHT=${DECORATION_HEIGHT:-30}
DECORATION_WIDTH=${DECORATION_WIDTH:-2}

# Auto-detect decoration dimensions from a sample window
auto_detect_decorations() {
    echo "Auto-detecting window decoration dimensions..."
    echo "Please click on any window to sample decoration sizes..."
    
    # Get window ID
    local window_id=$(xdotool selectwindow 2>/dev/null)
    if [[ -z "$window_id" ]]; then
        echo "No window selected"
        return 1
    fi
    
    # Get detailed window information from xwininfo
    local frame_info=$(xwininfo -id "$window_id" 2>/dev/null)
    if [[ -z "$frame_info" ]]; then
        echo "Could not get window frame information"
        return 1
    fi
    
    # Parse xwininfo output for decoration detection
    local relative_x=$(echo "$frame_info" | grep "Relative upper-left X:" | awk '{print $4}')
    local relative_y=$(echo "$frame_info" | grep "Relative upper-left Y:" | awk '{print $4}')
    local border_width=$(echo "$frame_info" | grep "Border width:" | awk '{print $3}')
    
    # The relative coordinates show the client area offset from the frame
    # relative_y is the title bar height
    # relative_x * 2 is the total horizontal decoration (left + right borders)
    local detected_height=$((relative_y))
    local detected_width=$((relative_x * 2))
    
    # Add border width if present (most modern themes have border_width=0)
    if [[ -n "$border_width" && "$border_width" -gt 0 ]]; then
        detected_width=$((detected_width + border_width * 2))
    fi
    
    echo "Detection results:"
    echo "  Relative client position: ${relative_x},${relative_y}"
    echo "  Border width: ${border_width}px"
    echo "  Detected decoration width: ${detected_width}px (left+right borders)"
    echo "  Detected decoration height: ${detected_height}px (title bar)"
    
    # Sanity check - typical values should be reasonable
    if [[ "$detected_height" -lt 0 || "$detected_height" -gt 50 ]]; then
        echo "Warning: Detected height ($detected_height) seems unusual"
    fi
    if [[ "$detected_width" -lt 0 || "$detected_width" -gt 20 ]]; then
        echo "Warning: Detected width ($detected_width) seems unusual"  
    fi
    
    # Offer to save the detected values
    read -p "Update configuration with detected values? [y/N]: " confirm
    if [[ "$confirm" == [yY] ]]; then
        update_setting "DECORATION_WIDTH" "$detected_width"
        update_setting "DECORATION_HEIGHT" "$detected_height"
        echo "âœ“ Configuration updated"
        echo "  Decoration width: ${detected_width}px"
        echo "  Decoration height: ${detected_height}px"
        echo "Restart place-window for changes to take effect."
    else
        echo "Configuration not changed"
    fi
}

# Common helper functions to avoid code duplication (DRY principle)

# Initialize common layout variables in current scope (used in 17+ functions)
# Usage: init_layout_vars "$monitor"
init_layout_vars() {
    local monitor="$1"
    layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    gap=$GAP
    decoration_h=$DECORATION_HEIGHT
    decoration_w=$DECORATION_WIDTH
    final_x=$((usable_x + gap))
    final_y=$((usable_y + gap))
    final_w=$((usable_w - gap * 2 - decoration_w))
    final_h=$((usable_h - gap * 2 - decoration_h))
}

# Gather windows for a specific monitor (used in 6+ functions)
gather_monitor_windows() {
    local monitor="$1"
    local window_list=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && window_list+=("$line")
    done < <(get_visible_windows_on_monitor "$monitor")
    
    printf '%s\n' "${window_list[@]}"
}

# Update a setting in settings file (used multiple times)
update_setting() {
    local setting_name="$1"
    local new_value="$2"
    sed -i "s/^${setting_name}=.*/${setting_name}=${new_value}/" "$SETTINGS_FILE"
}

# Workspace state tracking functions
get_current_workspace() {
    # Get current desktop/workspace number
    xdotool get_desktop 2>/dev/null || echo "0"
}

save_workspace_meta_layout() {
    local workspace="$1"
    local meta_layout="$2"
    
    # Initialize workspace state file if it doesn't exist
    [[ ! -f "$WORKSPACE_STATE_FILE" ]] && touch "$WORKSPACE_STATE_FILE"
    
    # Remove any existing entry for this workspace and add new one
    grep -v "^WORKSPACE_${workspace}_META=" "$WORKSPACE_STATE_FILE" > "${WORKSPACE_STATE_FILE}.tmp" 2>/dev/null || touch "${WORKSPACE_STATE_FILE}.tmp"
    echo "WORKSPACE_${workspace}_META=${meta_layout}" >> "${WORKSPACE_STATE_FILE}.tmp"
    mv "${WORKSPACE_STATE_FILE}.tmp" "$WORKSPACE_STATE_FILE"
}

get_workspace_meta_layout() {
    local workspace="$1"
    
    # Return the last meta-layout used on this workspace, or "auto" as default
    if [[ -f "$WORKSPACE_STATE_FILE" ]]; then
        local layout=$(grep "^WORKSPACE_${workspace}_META=" "$WORKSPACE_STATE_FILE" | cut -d'=' -f2-)
        [[ -n "$layout" ]] && echo "$layout" || echo "auto"
    else
        echo "auto"
    fi
}

# Function to pick a window with mouse
pick_window() {
    echo "Click on a window to select it..." >&2
    xdotool selectwindow
}

# Function to get current window geometry
get_window_geometry() {
    local id="$1"
    xwininfo -id "$id" | awk '
        /Absolute upper-left X:/ {x=$NF}
        /Absolute upper-left Y:/ {y=$NF}
        /Width:/ {w=$NF}
        /Height:/ {h=$NF}
        END {print x","y","w","h}
    '
}

# Function to apply geometry to window
apply_geometry() {
    local id="$1" x="$2" y="$3" w="$4" h="$5"
    wmctrl -i -r "$id" -e "0,${x},${y},${w},${h}"
    echo "Window positioned at: X=$x, Y=$y, Width=$w, Height=$h"
}

# Function to move window to workspace
move_to_workspace() {
    local id="$1" ws="$2"
    wmctrl -i -r "$id" -t "$ws"
    echo "Window moved to workspace $((ws + 1))"
}

# Function to save window position
save_position() {
    local name="$1" id="$2"
    local geom=$(get_window_geometry "$id")
    
    # Remove existing entry if exists
    grep -v "^${name}=" "$PRESETS_FILE" > "${PRESETS_FILE}.tmp" || true
    mv "${PRESETS_FILE}.tmp" "$PRESETS_FILE"
    
    # Add new entry
    echo "${name}=${geom}" >> "$PRESETS_FILE"
    echo "Position saved as '$name': $geom"
}

# Function to load saved position
load_position() {
    local name="$1" id="$2"
    local geom=$(grep "^${name}=" "$PRESETS_FILE" 2>/dev/null | cut -d= -f2)
    
    if [[ -z "$geom" ]]; then
        echo "Error: Preset '$name' not found"
        echo "Available presets:"
        grep -v '^#' "$PRESETS_FILE" | cut -d= -f1 | sed 's/^/  - /'
        exit 1
    fi
    
    IFS=',' read -r x y w h <<< "$geom"
    apply_geometry "$id" "$x" "$y" "$w" "$h"
}

# Get screen and monitor information
get_screen_info() {
    # Get total screen dimensions
    local screen_geom
    screen_geom=$(xdotool getdisplaygeometry)
    read -r SCREEN_W SCREEN_H <<< "$screen_geom"
    export SCREEN_W SCREEN_H
    
    # Get monitor information using xrandr
    MONITORS=()
    while IFS= read -r line; do
        if [[ $line =~ ^([^[:space:]]+)[[:space:]]+connected[[:space:]]+([0-9]+x[0-9]+\+[0-9]+\+[0-9]+) ]]; then
            local name="${BASH_REMATCH[1]}"
            local geometry="${BASH_REMATCH[2]}"
            # Parse geometry: WIDTHxHEIGHT+X+Y
            if [[ $geometry =~ ^([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+)$ ]]; then
                local w="${BASH_REMATCH[1]}"
                local h="${BASH_REMATCH[2]}"
                local x="${BASH_REMATCH[3]}"
                local y="${BASH_REMATCH[4]}"
                MONITORS+=("$name:$x:$y:$w:$h")
            fi
        fi
    done < <(xrandr --query 2>/dev/null)
    
    export MONITORS
    
    # If no monitors detected, create a fallback for the entire screen
    if [[ ${#MONITORS[@]} -eq 0 ]]; then
        MONITORS=("default:0:0:$SCREEN_W:$SCREEN_H")
    fi
}

# Get the primary monitor (where the panel is located)
get_primary_monitor() {
    # Try xrandr primary detection first
    local primary_output=$(xrandr --query 2>/dev/null | grep " primary " | cut -d' ' -f1)
    
    if [[ -n "$primary_output" ]]; then
        # Find the monitor entry that matches the primary output
        for monitor in "${MONITORS[@]}"; do
            IFS=':' read -r name x y w h <<< "$monitor"
            if [[ "$name" == "$primary_output" ]]; then
                echo "$monitor"
                return 0
            fi
        done
    fi
    
    # Fallback: assume monitor at coordinates 0,0 is primary (panel location)
    for monitor in "${MONITORS[@]}"; do
        IFS=':' read -r name x y w h <<< "$monitor"
        if [[ $x -eq 0 && $y -eq 0 ]]; then
            echo "$monitor"
            return 0
        fi
    done
    
    # Last resort: use first monitor
    echo "${MONITORS[0]}"
}

# Get which monitor a window is primarily on
get_window_monitor() {
    local window_id="$1"
    local geom=$(get_window_geometry "$window_id")
    IFS=',' read -r wx wy ww wh <<< "$geom"
    
    local best_monitor=""
    local best_overlap=0
    
    for monitor in "${MONITORS[@]}"; do
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        
        # Calculate overlap area
        local overlap_x1=$((wx > mx ? wx : mx))
        local overlap_y1=$((wy > my ? wy : my))
        local overlap_x2=$(((wx + ww) < (mx + mw) ? (wx + ww) : (mx + mw)))
        local overlap_y2=$(((wy + wh) < (my + mh) ? (wy + wh) : (my + mh)))
        
        if [[ $overlap_x2 -gt $overlap_x1 && $overlap_y2 -gt $overlap_y1 ]]; then
            local overlap_area=$(((overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1)))
            if [[ $overlap_area -gt $best_overlap ]]; then
                best_overlap=$overlap_area
                best_monitor="$monitor"
            fi
        fi
    done
    
    # If no overlap found, use first monitor
    [[ -z "$best_monitor" ]] && best_monitor="${MONITORS[0]}"
    echo "$best_monitor"
}

# Get monitor-specific layout area (clean - only accounts for panel space)
get_monitor_layout_area() {
    local monitor="$1"
    IFS=':' read -r name mx my mw mh <<< "$monitor"
    
    local panel_height=$PANEL_HEIGHT
    local panel_autohide="${PANEL_AUTOHIDE:-false}"
    
    # Get the actual primary monitor (where panel is located)
    local primary_monitor=$(get_primary_monitor)
    IFS=':' read -r primary_name primary_x primary_y primary_w primary_h <<< "$primary_monitor"
    
    local usable_x=$mx
    local usable_y=$my
    local usable_w=$mw
    local usable_h
    
    # Check if this monitor is the primary monitor (has the panel)
    local is_primary=false
    if [[ "$name" == "$primary_name" ]]; then
        is_primary=true
    fi
    
    # Handle panel space - only subtract panel height from primary monitor
    if [[ "$panel_autohide" == "true" ]]; then
        # Panel auto-hides - use full monitor space (windows can overlap panel area)
        # No height reduction needed since panel hides automatically
        usable_h=$mh
    else
        # Panel reserves space - start windows below it and reduce height
        if [[ "$is_primary" == "true" ]]; then
            # Panel at top reserves space, so start windows below it
            usable_y=$((my + panel_height))
            usable_h=$((mh - panel_height))
        else
            # No panel on this monitor - use full monitor space
            usable_h=$mh
        fi
    fi
    
    echo "$usable_x:$usable_y:$usable_w:$usable_h"
}

# Function to ensure minimum window size
ensure_minimum_size() {
    local w="$1" h="$2"
    w=$((w < MIN_WIDTH ? MIN_WIDTH : w))
    h=$((h < MIN_HEIGHT ? MIN_HEIGHT : h))
    echo "$w $h"
}

# Function to get all visible windows (not minimized or maximized)
get_visible_windows() {
    local current_desktop=$(xdotool get_desktop)
    wmctrl -l | while read -r line; do
        local id=$(echo "$line" | awk '{print $1}')
        local desktop=$(echo "$line" | awk '{print $2}')
        
        # Skip windows not on current desktop
        [[ "$desktop" != "$current_desktop" && "$desktop" != "-1" ]] && continue
        
        # Check if window is minimized or maximized
        local state=$(xprop -id "$id" _NET_WM_STATE 2>/dev/null | grep -E "HIDDEN|MAXIMIZED")
        [[ -n "$state" ]] && continue
        
        # Skip panels, docks, and desktop
        local type=$(xprop -id "$id" _NET_WM_WINDOW_TYPE 2>/dev/null)
        if echo "$type" | grep -qE "DOCK|DESKTOP|TOOLBAR|MENU|SPLASH|NOTIFICATION"; then
            continue
        fi
        
        echo "$id"
    done
}

get_visible_windows_on_monitor() {
    local monitor="$1"
    get_visible_windows | while read -r id; do
        local window_monitor=$(get_window_monitor "$id")
        if [[ "$window_monitor" == "$monitor" ]]; then
            echo "$id"
        fi
    done
}

# Legacy auto-layout functions removed - now using atomic functions with proper monitor support

# Single-monitor meta-layout helper functions for auto-layout consistency
apply_meta_maximize_single_monitor() {
    local monitor="$1"
    shift
    local window_list=("$@")
    
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    local gap=$GAP
    local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
    
    # Maximize first window with decoration space, minimize others
    local final_w=$((usable_w - gap * 2 - decoration_w))
    local final_h=$((usable_h - gap * 2 - decoration_h))
    apply_geometry "${window_list[0]}" $((usable_x + gap)) $((usable_y + gap)) $final_w $final_h
    for ((i=1; i<${#window_list[@]}; i++)); do
        xdotool windowminimize "${window_list[i]}" 2>/dev/null
    done
}

apply_meta_columns_single_monitor() {
    local monitor="$1"
    shift
    local window_list=("$@")
    
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local gap=$GAP
    local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
    local final_x=$((usable_x + gap))
    local final_y=$((usable_y + gap))
    local final_w=$((usable_w - gap * 2 - decoration_w))
    local final_h=$((usable_h - gap * 2 - decoration_h))
    
    local num_windows=${#window_list[@]}
    local available_w=$((final_w - gap * (num_windows - 1)))
    local column_w=$((available_w / num_windows))
    
    for ((i=0; i<num_windows; i++)); do
        local x=$((final_x + i * (column_w + gap)))
        apply_geometry "${window_list[i]}" $x $final_y $column_w $final_h
    done
}

apply_meta_main_sidebar_single_monitor() {
    local monitor="$1"
    local main_width_percent="$2"
    shift 2
    local window_list=("$@")
    
    # Use helper function to avoid duplicate variable initialization (DRY principle)
    init_layout_vars "$monitor"
    
    local num_windows=${#window_list[@]}
    
    # If only 1 window, use maximize atomic function
    if [[ $num_windows -eq 1 ]]; then
        apply_meta_maximize_single_monitor "$monitor" "${window_list[@]}"
        return
    fi
    
    # For 2+ windows, do main-sidebar layout
    local gap_between=$((gap + decoration_w))  # Gap + decoration between main and sidebar
    local available_w=$((final_w - gap_between))  # Total width minus gap between windows
    local main_w=$((available_w * main_width_percent / 100))
    local sidebar_w=$((available_w - main_w))
    local sidebar_x=$((final_x + main_w + gap_between))
    
    # Position main window
    apply_geometry "${window_list[0]}" $final_x $final_y $main_w $final_h
    
    # Position sidebar windows (stacked) - account for decorations in vertical spacing
    local sidebar_windows=$((num_windows - 1))
    local gap_vertical=$((gap + decoration_h))  # Gap + decoration between stacked windows
    local available_sidebar_h=$((final_h - gap_vertical * (sidebar_windows - 1)))
    local sidebar_h=$((available_sidebar_h / sidebar_windows))
    
    for ((i=1; i<num_windows; i++)); do
        local sidebar_y=$((final_y + (i - 1) * (sidebar_h + gap_vertical)))
        apply_geometry "${window_list[i]}" $sidebar_x $sidebar_y $sidebar_w $sidebar_h
    done
}

apply_meta_grid_single_monitor() {
    local monitor="$1"
    shift
    local window_list=("$@")
    
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local num_windows=${#window_list[@]}
    local cols=$(( (num_windows + 1) / 2 ))
    local rows=$(( (num_windows + cols - 1) / cols ))
    
    local gap=$GAP
    local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
    local gap_vertical=$((gap + decoration_h))  # Gap + decoration for vertical spacing
    
    # Account for gaps and decorations between rows
    local available_w=$((usable_w - gap * (cols + 1)))  # Left, right, and between columns
    local available_h=$((usable_h - gap * 2 - gap_vertical * (rows - 1) - decoration_h))  # Top/bottom gaps, vertical gaps, decoration
    local cell_w=$((available_w / cols))
    local cell_h=$((available_h / rows))
    
    for ((i=0; i<num_windows; i++)); do
        local col=$((i % cols))
        local row=$((i / cols))
        local x=$((usable_x + gap + col * (cell_w + gap)))
        local y=$((usable_y + gap + row * (cell_h + gap_vertical)))
        apply_geometry "${window_list[i]}" $x $y $cell_w $cell_h
    done
}

apply_meta_topbar_main_single_monitor() {
    local monitor="$1"
    local topbar_height_percent="$2"
    shift 2
    local window_list=("$@")
    
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local gap=$GAP
    local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
    local final_x=$((usable_x + gap))
    local final_y=$((usable_y + gap))
    local final_w=$((usable_w - gap * 2 - decoration_w))
    local final_h=$((usable_h - gap * 2 - decoration_h))  # Account for decorations in height only
    
    local num_windows=${#window_list[@]}
    
    # If only 1 window, use maximize atomic function
    if [[ $num_windows -eq 1 ]]; then
        apply_meta_maximize_single_monitor "$monitor" "${window_list[@]}"
        return
    fi
    
    # Calculate topbar and main heights with gap and decoration between them
    local gap_vertical=$((gap + decoration_h))  # Gap + decoration between topbar and main
    local available_h=$((final_h - gap_vertical))  # Available height minus vertical gap
    local topbar_h=$((available_h * topbar_height_percent / 100))
    local main_h=$((available_h - topbar_h))
    local main_y=$((final_y + topbar_h + gap_vertical))
    
    # Position main window (last window) - takes full width at bottom
    local main_window_index=$((num_windows - 1))
    apply_geometry "${window_list[main_window_index]}" $final_x $main_y $final_w $main_h
    
    # Position topbar windows (all except last) in columns
    local topbar_windows=$((num_windows - 1))
    if [[ $topbar_windows -gt 0 ]]; then
        local available_topbar_w=$((final_w - gap * (topbar_windows - 1)))
        local topbar_column_w=$((available_topbar_w / topbar_windows))
        
        for ((i=0; i<topbar_windows; i++)); do
            local topbar_x=$((final_x + i * (topbar_column_w + gap)))
            apply_geometry "${window_list[i]}" $topbar_x $final_y $topbar_column_w $topbar_h
        done
    fi
}

apply_meta_center_corners_single_monitor() {
    local monitor="$1"
    shift
    local window_list=("$@")
    
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local gap=$GAP
    local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
    
    # Account for decorations in height calculation only
    local gap_vertical=$((gap + decoration_h))  # Gap + decoration for vertical spacing
    local available_w=$((usable_w - gap * 4))  # Left, right, and 2 side gaps
    local available_h=$((usable_h - gap * 2 - gap_vertical * 2 - decoration_h))  # Top/bottom gaps + 2 vertical decoration gaps
    
    local corner_w=$((available_w * 30 / 100))
    local corner_h=$((available_h * 40 / 100))
    local center_w=$((available_w - corner_w * 2))
    local center_h=$((available_h - corner_h * 2))
    
    # Calculate positions (no decoration offset in positioning)
    local center_x=$((usable_x + gap + corner_w + gap))
    local center_y=$((usable_y + gap + corner_h + gap_vertical))
    
    # Position center window first (ids[0])
    apply_geometry "${window_list[0]}" $center_x $center_y $center_w $center_h
    
    # Position corner windows
    # Top corners (ids[1], ids[2])
    apply_geometry "${window_list[1]}" $((usable_x + gap)) $((usable_y + gap)) $corner_w $corner_h
    apply_geometry "${window_list[2]}" $((usable_x + usable_w - gap - corner_w)) $((usable_y + gap)) $corner_w $corner_h
    
    # Bottom corners (ids[3], ids[4]) - account for decoration in vertical spacing
    local bottom_corner_y=$((usable_y + gap + corner_h + gap_vertical + center_h + gap_vertical))
    apply_geometry "${window_list[3]}" $((usable_x + gap)) $bottom_corner_y $corner_w $corner_h
    apply_geometry "${window_list[4]}" $((usable_x + usable_w - gap - corner_w)) $bottom_corner_y $corner_w $corner_h
}

# Main auto-layout function (monitor-aware)
auto_layout() {
    echo "Detecting visible windows..."
    local windows=($(get_visible_windows))
    local count=${#windows[@]}
    
    if [[ $count -eq 0 ]]; then
        echo "No visible windows found"
        return 1
    fi
    
    get_screen_info
    
    # Group windows by monitor
    declare -A monitor_windows
    for window_id in "${windows[@]}"; do
        local monitor=$(get_window_monitor "$window_id")
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        local key="${mx},${my}"  # Use coordinates as unique key
        if [[ "${monitor_windows[$key]:-}" ]]; then
            monitor_windows[$key]="${monitor_windows[$key]} $window_id"
        else
            monitor_windows[$key]="$window_id"
        fi
    done
    
    echo "Found $count visible window(s) across ${#monitor_windows[@]} monitor(s)"
    
    # Apply layout to each monitor's windows
    for key in "${!monitor_windows[@]}"; do
        local window_list=(${monitor_windows[$key]})
        local window_count=${#window_list[@]}
        
        # Find the monitor info for this group
        local target_monitor=""
        for monitor in "${MONITORS[@]}"; do
            IFS=':' read -r name mx my mw mh <<< "$monitor"
            if [[ "$key" == "${mx},${my}" ]]; then
                target_monitor="$monitor"
                break
            fi
        done
        
        if [[ -n "$target_monitor" ]]; then
            IFS=':' read -r name mx my mw mh <<< "$target_monitor"
            echo "Monitor $name: Arranging $window_count window(s)"
            
            # Apply consistent meta-layout based on window count on this monitor
            case $window_count in
                1)
                    echo "  Applying 1-window layout: meta maximize"
                    # Temporarily set windows for this monitor only for meta-layout
                    apply_meta_maximize_single_monitor "$target_monitor" "${window_list[@]}"
                    ;;
                2)
                    echo "  Applying 2-window layout: meta columns"
                    apply_meta_columns_single_monitor "$target_monitor" "${window_list[@]}"
                    ;;
                3)
                    echo "  Applying 3-window layout: meta main-sidebar-50"
                    apply_meta_main_sidebar_single_monitor "$target_monitor" 50 "${window_list[@]}"
                    ;;
                4)
                    echo "  Applying 4-window layout: meta grid"
                    apply_meta_grid_single_monitor "$target_monitor" "${window_list[@]}"
                    ;;
                5)
                    echo "  Applying 5-window layout: meta topbar-main-70"
                    apply_meta_topbar_main_single_monitor "$target_monitor" 70 "${window_list[@]}"
                    ;;
                *)
                    echo "  Applying ${window_count}-window layout: meta grid"
                    apply_meta_grid_single_monitor "$target_monitor" "${window_list[@]}"
                    ;;
            esac
        fi
    done
    
    echo "Multi-monitor auto-layout applied successfully"
}

# Monitor-specific auto-layout functions
auto_layout_monitor_1_window() {
    local monitor="$1" id="$2"
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    # Maximize with gaps
    local gap=$GAP
    local final_x=$((usable_x + gap))
    local final_y=$((usable_y + gap))
    local final_w=$((usable_w - gap * 2 - decoration_w))
    local final_h=$((usable_h - gap * 2))
    apply_geometry "$id" $final_x $final_y $final_w $final_h
}

auto_layout_monitor_2_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        equal)
            # 50/50 split - use columns atomic function
            apply_meta_columns_single_monitor "$monitor" "${ids[@]}"
            ;;
        primary-secondary)
            # 70/30 split - use main-sidebar atomic function
            apply_meta_main_sidebar_single_monitor "$monitor" 70 "${ids[@]}"
            ;;
        secondary-primary)
            # 30/70 split - use main-sidebar atomic function  
            apply_meta_main_sidebar_single_monitor "$monitor" 30 "${ids[@]}"
            ;;
    esac
}

auto_layout_monitor_3_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        main-two-side)
            # One left half, two stacked on right - use main-sidebar atomic function
            apply_meta_main_sidebar_single_monitor "$monitor" 50 "${ids[@]}"
            ;;
        three-columns)
            # Three equal columns - use columns atomic function
            apply_meta_columns_single_monitor "$monitor" "${ids[@]}"
            ;;
        center-sidebars)
            # 20/60/20 split - use columns atomic function (it handles any number equally)
            apply_meta_columns_single_monitor "$monitor" "${ids[@]}"
            ;;
    esac
}

auto_layout_monitor_4_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        grid)
            # 2x2 grid - use grid atomic function
            apply_meta_grid_single_monitor "$monitor" "${ids[@]}"
            ;;
        main-three-side)
            # One left half, three stacked on right - use main-sidebar atomic function
            apply_meta_main_sidebar_single_monitor "$monitor" 50 "${ids[@]}"
            ;;
        three-top-bottom)
            # Three columns on top, one wide bottom - use topbar-main atomic function
            apply_meta_topbar_main_single_monitor "$monitor" 60 "${ids[@]}"
            ;;
    esac
}

auto_layout_monitor_5_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        center-corners)
            # One center, four corners - use center-corners atomic function
            apply_meta_center_corners_single_monitor "$monitor" "${ids[@]}"
            ;;
        two-three-columns)
            # 2 windows on left, 3 on right - use main-sidebar with 40% main area
            apply_meta_main_sidebar_single_monitor "$monitor" 40 "${ids[@]}"
            ;;
        grid-wide-bottom)
            # 2x2 grid on top, one wide on bottom - use topbar-main with 60% topbar
            apply_meta_topbar_main_single_monitor "$monitor" 60 "${ids[@]}"
            ;;
    esac
}

# Function to find adjacent windows (side-by-side or stacked)
find_adjacent_windows() {
    local target_id="$1"
    local target_geom=$(get_window_geometry "$target_id")
    IFS=',' read -r tx ty tw th <<< "$target_geom"
    
    local adjacent=()
    local windows=($(get_visible_windows))
    
    for id in "${windows[@]}"; do
        [[ "$id" == "$target_id" ]] && continue
        
        local geom=$(get_window_geometry "$id")
        IFS=',' read -r x y w h <<< "$geom"
        
        # Check if windows share an edge (horizontally or vertically adjacent)
        local gap_tolerance=20  # Allow for small gaps
        
        # Horizontal adjacency (side by side)
        if [[ $((ty - gap_tolerance)) -le $((y + h)) && $((ty + th + gap_tolerance)) -ge $y ]]; then
            # Left adjacent
            if [[ $((tx - gap_tolerance)) -le $((x + w)) && $((tx - gap_tolerance)) -ge $x ]]; then
                adjacent+=("$id:left")
            fi
            # Right adjacent  
            if [[ $((tx + tw + gap_tolerance)) -ge $x && $((tx + tw - gap_tolerance)) -le $((x + w)) ]]; then
                adjacent+=("$id:right")
            fi
        fi
        
        # Vertical adjacency (stacked)
        if [[ $((tx - gap_tolerance)) -le $((x + w)) && $((tx + tw + gap_tolerance)) -ge $x ]]; then
            # Top adjacent
            if [[ $((ty - gap_tolerance)) -le $((y + h)) && $((ty - gap_tolerance)) -ge $y ]]; then
                adjacent+=("$id:top")
            fi
            # Bottom adjacent
            if [[ $((ty + th + gap_tolerance)) -ge $y && $((ty + th - gap_tolerance)) -le $((y + h)) ]]; then
                adjacent+=("$id:bottom")
            fi
        fi
    done
    
    printf '%s\n' "${adjacent[@]}"
}

# Simultaneous resize function
simultaneous_resize() {
    local direction="$1"  # expand-right, shrink-right, expand-down, shrink-down
    local amount="${2:-50}"  # pixels to resize
    
    local target_id=$(pick_window)
    echo "Finding adjacent windows..."
    
    local adjacent=($(find_adjacent_windows "$target_id"))
    if [[ ${#adjacent[@]} -eq 0 ]]; then
        echo "No adjacent windows found for simultaneous resize"
        return 1
    fi
    
    echo "Found ${#adjacent[@]} adjacent window(s)"
    
    local target_geom=$(get_window_geometry "$target_id")
    IFS=',' read -r tx ty tw th <<< "$target_geom"
    
    case "$direction" in
        expand-right|shrink-right)
            local new_tw=$((tw + (direction == "expand-right" ? amount : -amount)))
            apply_geometry "$target_id" $tx $ty $new_tw $th
            
            # Adjust right-adjacent windows
            for adj in "${adjacent[@]}"; do
                local adj_id="${adj%:*}"
                local adj_dir="${adj#*:}"
                if [[ "$adj_dir" == "right" ]]; then
                    local adj_geom=$(get_window_geometry "$adj_id")
                    IFS=',' read -r ax ay aw ah <<< "$adj_geom"
                    local new_ax=$((ax + (direction == "expand-right" ? amount : -amount)))
                    local new_aw=$((aw + (direction == "expand-right" ? -amount : amount)))
                    apply_geometry "$adj_id" $new_ax $ay $new_aw $ah
                fi
            done
            ;;
        expand-down|shrink-down)
            local new_th=$((th + (direction == "expand-down" ? amount : -amount)))
            apply_geometry "$target_id" $tx $ty $tw $new_th
            
            # Adjust bottom-adjacent windows
            for adj in "${adjacent[@]}"; do
                local adj_id="${adj%:*}"
                local adj_dir="${adj#*:}"
                if [[ "$adj_dir" == "bottom" ]]; then
                    local adj_geom=$(get_window_geometry "$adj_id")
                    IFS=',' read -r ax ay aw ah <<< "$adj_geom"
                    local new_ay=$((ay + (direction == "expand-down" ? amount : -amount)))
                    local new_ah=$((ah + (direction == "expand-down" ? -amount : amount)))
                    apply_geometry "$adj_id" $new_ax $new_ay $aw $new_ah
                fi
            done
            ;;
    esac
    
    echo "Simultaneous resize completed"
}

# Master-stack layouts (xpytile-inspired)
master_stack_layout() {
    local orientation="$1"  # vertical or horizontal
    local percentage="${2:-60}"  # master window percentage (default 60%)
    local windows=($(get_visible_windows))
    local count=${#windows[@]}
    
    if [[ $count -lt 2 ]]; then
        echo "Master-stack requires at least 2 windows"
        return 1
    fi
    
    # Group windows by monitor and apply master-stack layout to each monitor
    get_screen_info
    local monitors_with_windows=()
    
    # Group windows by monitor
    for monitor in "${MONITORS[@]}"; do
        local windows_on_monitor=()
        for window_id in "${windows[@]}"; do
            local window_monitor=$(get_window_monitor "$window_id")
            if [[ "$window_monitor" == "$monitor" ]]; then
                windows_on_monitor+=("$window_id")
            fi
        done
        
        if [[ ${#windows_on_monitor[@]} -gt 0 ]]; then
            monitors_with_windows+=("$monitor")
            local num_windows=${#windows_on_monitor[@]}
            
            IFS=':' read -r name mx my mw mh <<< "$monitor"
            echo "Monitor $name: Applying master-stack ($orientation, ${percentage}%) to $num_windows window(s)"
            
            if [[ "$orientation" == "vertical" ]]; then
                # Master on left, stack on right - use main-sidebar atomic function
                apply_meta_main_sidebar_single_monitor "$monitor" "$percentage" "${windows_on_monitor[@]}"
            else
                # Master on top, stack on bottom - use topbar-main atomic function  
                apply_meta_topbar_main_single_monitor "$monitor" "$percentage" "${windows_on_monitor[@]}"
            fi
        fi
    done
    
    echo "Master-stack layout ($orientation) applied to ${#monitors_with_windows[@]} monitor(s)"
}

# Focus navigation
focus_window() {
    local direction="$1"  # next, prev, up, down, left, right
    local current_id=$(xdotool getactivewindow 2>/dev/null || echo "")
    
    if [[ -z "$current_id" ]]; then
        echo "No active window found"
        return 1
    fi
    
    local windows=($(get_visible_windows))
    local target_id=""
    
    case "$direction" in
        next)
            # Find next window in list
            for i in "${!windows[@]}"; do
                if [[ "${windows[i]}" == "$current_id" ]]; then
                    target_id="${windows[$(((i + 1) % ${#windows[@]}))]}"
                    break
                fi
            done
            ;;
        prev)
            # Find previous window in list
            for i in "${!windows[@]}"; do
                if [[ "${windows[i]}" == "$current_id" ]]; then
                    target_id="${windows[$(((i - 1 + ${#windows[@]}) % ${#windows[@]}))]}"
                    break
                fi
            done
            ;;
        up|down|left|right)
            # Find geometrically adjacent window
            local current_geom=$(get_window_geometry "$current_id")
            IFS=',' read -r cx cy cw ch <<< "$current_geom"
            local best_distance=999999
            
            for id in "${windows[@]}"; do
                [[ "$id" == "$current_id" ]] && continue
                
                local geom=$(get_window_geometry "$id")
                IFS=',' read -r x y w h <<< "$geom"
                
                case "$direction" in
                    up)    [[ $((y + h)) -le $cy ]] && distance=$((cy - (y + h))) ;;
                    down)  [[ $y -ge $((cy + ch)) ]] && distance=$((y - (cy + ch))) ;;
                    left)  [[ $((x + w)) -le $cx ]] && distance=$((cx - (x + w))) ;;
                    right) [[ $x -ge $((cx + cw)) ]] && distance=$((x - (cx + cw))) ;;
                esac
                
                if [[ ${distance:-999999} -lt $best_distance ]]; then
                    best_distance=$distance
                    target_id="$id"
                fi
            done
            ;;
    esac
    
    if [[ -n "$target_id" ]]; then
        xdotool windowactivate "$target_id"
        echo "Focused window: $target_id"
    else
        echo "No window found in direction: $direction"
    fi
}

# Apply preset layouts with configurable gaps (monitor-aware)
apply_preset() {
    local preset="$1" id="$2"
    get_screen_info
    
    # Determine which monitor the window is primarily on
    local monitor=$(get_window_monitor "$id")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local half_w=$((usable_w / 2))
    local half_h=$((usable_h / 2))
    
    local gap=$GAP
    local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
    
    case "$preset" in
        ul) # Upper left
            read -r w h <<< "$(ensure_minimum_size $((half_w - gap)) $((half_h - gap - decoration_h)))"
            apply_geometry "$id" $((usable_x + gap)) $((usable_y + gap)) $w $h
            ;;
        ur) # Upper right
            read -r w h <<< "$(ensure_minimum_size $((half_w - gap)) $((half_h - gap - decoration_h)))"
            apply_geometry "$id" $((usable_x + half_w + gap)) $((usable_y + gap)) $w $h
            ;;
        ll) # Lower left
            read -r w h <<< "$(ensure_minimum_size $((half_w - gap)) $((half_h - gap - decoration_h)))"
            apply_geometry "$id" $((usable_x + gap)) $((usable_y + half_h + gap)) $w $h
            ;;
        lr) # Lower right
            read -r w h <<< "$(ensure_minimum_size $((half_w - gap)) $((half_h - gap - decoration_h)))"
            apply_geometry "$id" $((usable_x + half_w + gap)) $((usable_y + half_h + gap)) $w $h
            ;;
        c) # Center
            local center_w=$((usable_w * 2 / 3 - gap * 2))
            local center_h=$((usable_h * 2 / 3 - gap * 2 - decoration_h))
            read -r center_w center_h <<< "$(ensure_minimum_size $center_w $center_h)"
            local center_x=$((usable_x + gap + (usable_w - center_w - gap * 2) / 2))
            local center_y=$((usable_y + gap + (usable_h - center_h - gap * 2 - decoration) / 2))
            apply_geometry "$id" $center_x $center_y $center_w $center_h
            ;;
        left) # Left half
            read -r w h <<< "$(ensure_minimum_size $((half_w - gap)) $((usable_h - gap * 2 - decoration_h)))"
            apply_geometry "$id" $((usable_x + gap)) $((usable_y + gap)) $w $h
            ;;
        right) # Right half
            read -r w h <<< "$(ensure_minimum_size $((half_w - gap)) $((usable_h - gap * 2 - decoration_h)))"
            apply_geometry "$id" $((usable_x + half_w + gap)) $((usable_y + gap)) $w $h
            ;;
        top) # Top half
            read -r w h <<< "$(ensure_minimum_size $((usable_w - gap * 2)) $((half_h - gap - decoration_h)))"
            apply_geometry "$id" $((usable_x + gap)) $((usable_y + gap)) $w $h
            ;;
        bottom) # Bottom half
            read -r w h <<< "$(ensure_minimum_size $((usable_w - gap * 2)) $((half_h - gap - decoration_h)))"
            apply_geometry "$id" $((usable_x + gap)) $((usable_y + half_h + gap)) $w $h
            ;;
        maximize) # Maximize (with gaps)
            local final_x=$((usable_x + gap))
            local final_y=$((usable_y + gap))
            local final_w=$((usable_w - gap * 2 - decoration_w))
            local final_h=$((usable_h - gap * 2 - decoration_h))
            read -r w h <<< "$(ensure_minimum_size $final_w $final_h)"
            apply_geometry "$id" $final_x $final_y $w $h
            ;;
        *)
            # Check if it's a saved preset
            load_position "$preset" "$id"
            ;;
    esac
}

# Interactive mode menu
interactive_mode() {
    local id=$(pick_window)
    
    echo ""
    echo "Window Positioning - Interactive Mode"
    echo "====================================="
    echo "Current settings: Gap=${GAP}px, Panel=${PANEL_HEIGHT}px"
    echo ""
    echo "Quick presets:"
    echo "  1) Upper left (ul)      6) Left half"
    echo "  2) Upper right (ur)     7) Right half"
    echo "  3) Lower left (ll)      8) Top half"
    echo "  4) Lower right (lr)     9) Bottom half"
    echo "  5) Center (c)          10) Maximize"
    echo ""
    echo "Other options:"
    echo "  s) Save current position    g) Set gap size"
    echo "  l) Load saved position      p) Set panel height"
    echo "  c) Custom coordinates       r) Reload settings"
    echo "  w) Move to workspace        q) Quit"
    echo ""
    
    read -p "Choose option: " choice
    
    case "$choice" in
        1|ul) apply_preset "ul" "$id" ;;
        2|ur) apply_preset "ur" "$id" ;;
        3|ll) apply_preset "ll" "$id" ;;
        4|lr) apply_preset "lr" "$id" ;;
        5|c) apply_preset "c" "$id" ;;
        6) apply_preset "left" "$id" ;;
        7) apply_preset "right" "$id" ;;
        8) apply_preset "top" "$id" ;;
        9) apply_preset "bottom" "$id" ;;
        10) apply_preset "maximize" "$id" ;;
        s)
            read -p "Enter name for this position: " name
            save_position "$name" "$id"
            ;;
        l)
            echo "Available presets:"
            grep -v '^#' "$PRESETS_FILE" | cut -d= -f1 | sed 's/^/  - /'
            read -p "Enter preset name: " name
            load_position "$name" "$id"
            ;;
        c)
            read -p "Enter X Y Width Height (space-separated): " x y w h
            apply_geometry "$id" "$x" "$y" "$w" "$h"
            ;;
        w)
            read -p "Enter workspace number (1-based): " ws
            move_to_workspace "$id" $((ws - 1))
            ;;
        g)
            read -p "Enter new gap size (current: ${GAP}px): " new_gap
            if [[ "$new_gap" =~ ^[0-9]+$ ]]; then
                sed -i "s/^GAP=.*/GAP=${new_gap}/" "$SETTINGS_FILE"
                GAP=$new_gap
                echo "Gap size set to ${new_gap}px"
            else
                echo "Invalid gap size. Must be a number."
            fi
            ;;
        p)
            read -p "Enter new panel height (current: ${PANEL_HEIGHT}px): " new_panel
            if [[ "$new_panel" =~ ^[0-9]+$ ]]; then
                sed -i "s/^PANEL_HEIGHT=.*/PANEL_HEIGHT=${new_panel}/" "$SETTINGS_FILE"
                PANEL_HEIGHT=$new_panel
                echo "Panel height set to ${new_panel}px"
            else
                echo "Invalid panel height. Must be a number."
            fi
            ;;
        r)
            source "$SETTINGS_FILE"
            echo "Settings reloaded: Gap=${GAP}px, Panel=${PANEL_HEIGHT}px"
            ;;
        q)
            echo "Exiting..."
            exit 0
            ;;
        *)
            echo "Invalid option"
            exit 1
            ;;
    esac
}

# Window swap functions
drag_swap_windows() {
    echo "Click on the first window to select it for swapping..."
    local window1_id
    window1_id=$(pick_window)
    
    if [[ -z "$window1_id" ]]; then
        echo "No window selected. Aborting swap."
        return 1
    fi
    
    # Get first window's geometry and info
    local window1_geom
    window1_geom=$(xdotool getwindowgeometry --shell "$window1_id" 2>/dev/null)
    local window1_title
    window1_title=$(xdotool getwindowname "$window1_id" 2>/dev/null)
    
    if [[ -z "$window1_geom" ]]; then
        echo "Error: Could not get geometry for selected window"
        return 1
    fi
    
    echo "Selected: $window1_title"
    echo "Now click on the second window to swap with..."
    
    local window2_id
    window2_id=$(pick_window)
    
    if [[ -z "$window2_id" ]]; then
        echo "No second window selected. Aborting swap."
        return 1
    fi
    
    if [[ "$window1_id" == "$window2_id" ]]; then
        echo "Cannot swap a window with itself"
        return 1
    fi
    
    # Get second window's geometry and info
    local window2_geom
    window2_geom=$(xdotool getwindowgeometry --shell "$window2_id" 2>/dev/null)
    local window2_title
    window2_title=$(xdotool getwindowname "$window2_id" 2>/dev/null)
    
    if [[ -z "$window2_geom" ]]; then
        echo "Error: Could not get geometry for second window"
        return 1
    fi
    
    echo "Swapping positions between:"
    echo "  Window 1: $window1_title"
    echo "  Window 2: $window2_title"
    
    # Perform the swap
    swap_window_positions "$window1_id" "$window2_id"
}

interactive_swap_windows() {
    echo "Interactive swap mode: Click on two windows to swap their positions"
    echo ""
    
    echo "Click on the first window..."
    local window1_id
    window1_id=$(pick_window)
    
    if [[ -z "$window1_id" ]]; then
        echo "No window selected. Aborting swap."
        return 1
    fi
    
    local window1_title
    window1_title=$(xdotool getwindowname "$window1_id" 2>/dev/null)
    echo "âœ“ Selected first window: $window1_title"
    echo ""
    
    echo "Click on the second window..."
    local window2_id
    window2_id=$(pick_window)
    
    if [[ -z "$window2_id" ]]; then
        echo "No second window selected. Aborting swap."
        return 1
    fi
    
    if [[ "$window1_id" == "$window2_id" ]]; then
        echo "Cannot swap a window with itself"
        return 1
    fi
    
    local window2_title
    window2_title=$(xdotool getwindowname "$window2_id" 2>/dev/null)
    echo "âœ“ Selected second window: $window2_title"
    echo ""
    
    echo "Swapping positions..."
    swap_window_positions "$window1_id" "$window2_id"
}

swap_window_positions() {
    local window1_id="$1"
    local window2_id="$2"
    
    # Get geometries
    local window1_geom window2_geom
    window1_geom=$(xdotool getwindowgeometry --shell "$window1_id" 2>/dev/null)
    window2_geom=$(xdotool getwindowgeometry --shell "$window2_id" 2>/dev/null)
    
    if [[ -z "$window1_geom" || -z "$window2_geom" ]]; then
        echo "Error: Could not get window geometries for swap"
        return 1
    fi
    
    # Parse window 1 geometry
    eval "$window1_geom"
    local w1_x=$X w1_y=$Y w1_width=$WIDTH w1_height=$HEIGHT
    
    # Parse window 2 geometry  
    eval "$window2_geom"
    local w2_x=$X w2_y=$Y w2_width=$WIDTH w2_height=$HEIGHT
    
    # Perform the swap with a small delay to avoid conflicts
    echo "  Moving windows..."
    
    # Move window 1 to window 2's position
    xdotool windowmove "$window1_id" "$w2_x" "$w2_y"
    xdotool windowsize "$window1_id" "$w2_width" "$w2_height"
    
    # Small delay to ensure first move completes
    sleep 0.1
    
    # Move window 2 to window 1's position
    xdotool windowmove "$window2_id" "$w1_x" "$w1_y" 
    xdotool windowsize "$window2_id" "$w1_width" "$w1_height"
    
    echo "âœ“ Windows swapped successfully"
    
    # Get window titles for confirmation
    local title1 title2
    title1=$(xdotool getwindowname "$window1_id" 2>/dev/null || echo "Window $window1_id")
    title2=$(xdotool getwindowname "$window2_id" 2>/dev/null || echo "Window $window2_id") 
    
    echo "  $title1 â†’ Position ${w2_x}Ã—${w2_y} (${w2_width}Ã—${w2_height})"
    echo "  $title2 â†’ Position ${w1_x}Ã—${w1_y} (${w1_width}Ã—${w1_height})"
}

cycle_window_positions() {
    # Rotate/cycle all visible windows through their positions clockwise
    echo "Cycling window positions clockwise..."
    
    # Get all visible windows
    local windows=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && windows+=("$line")
    done < <(get_visible_windows)
    
    local window_count=${#windows[@]}
    
    if [[ $window_count -lt 2 ]]; then
        echo "Need at least 2 windows to cycle positions"
        return 1
    fi
    
    echo "Found $window_count windows to cycle"
    
    # Get all window geometries
    local geometries=()
    local titles=()
    
    for window_id in "${windows[@]}"; do
        local geom
        geom=$(get_geometry "$window_id")
        if [[ -n "$geom" ]]; then
            geometries+=("$geom")
            local title
            title=$(xdotool getwindowname "$window_id" 2>/dev/null || echo "Window $window_id")
            titles+=("$title")
        else
            echo "Warning: Could not get geometry for window $window_id"
            return 1
        fi
    done
    
    echo "Cycling positions..."
    
    # Cycle: each window moves to the next window's position
    # Window 0 â†’ Position 1, Window 1 â†’ Position 2, ..., Last Window â†’ Position 0
    for ((i=0; i<window_count; i++)); do
        local next_pos_index=$(( (i + 1) % window_count ))
        local current_window="${windows[i]}"
        local target_geometry="${geometries[next_pos_index]}"
        
        # Parse target geometry
        eval "$target_geometry"
        local target_x=$X target_y=$Y target_width=$WIDTH target_height=$HEIGHT
        
        # Move current window to target position
        apply_geometry "$current_window" "$target_x" "$target_y" "$target_width" "$target_height"
        
        echo "  ${titles[i]} â†’ Position ${target_x}Ã—${target_y} (${target_width}Ã—${target_height})"
    done
    
    echo "âœ“ Window positions cycled successfully"
}

reverse_cycle_window_positions() {
    # Rotate/cycle all visible windows through their positions counter-clockwise  
    echo "Cycling window positions counter-clockwise..."
    
    # Get all visible windows
    local windows=()
    while IFS= read -r line; do
        [[ -n "$line" ]] && windows+=("$line")
    done < <(get_visible_windows)
    
    local window_count=${#windows[@]}
    
    if [[ $window_count -lt 2 ]]; then
        echo "Need at least 2 windows to cycle positions"
        return 1
    fi
    
    echo "Found $window_count windows to cycle"
    
    # Get all window geometries
    local geometries=()
    local titles=()
    
    for window_id in "${windows[@]}"; do
        local geom
        geom=$(get_geometry "$window_id")
        if [[ -n "$geom" ]]; then
            geometries+=("$geom")
            local title
            title=$(xdotool getwindowname "$window_id" 2>/dev/null || echo "Window $window_id")
            titles+=("$title")
        else
            echo "Warning: Could not get geometry for window $window_id"
            return 1
        fi
    done
    
    echo "Reverse cycling positions..."
    
    # Reverse cycle: each window moves to the previous window's position
    # Window 0 â†’ Position (last), Window 1 â†’ Position 0, Window 2 â†’ Position 1, etc.
    for ((i=0; i<window_count; i++)); do
        local prev_pos_index=$(( (i - 1 + window_count) % window_count ))
        local current_window="${windows[i]}"
        local target_geometry="${geometries[prev_pos_index]}"
        
        # Parse target geometry
        eval "$target_geometry"
        local target_x=$X target_y=$Y target_width=$WIDTH target_height=$HEIGHT
        
        # Move current window to target position
        apply_geometry "$current_window" "$target_x" "$target_y" "$target_width" "$target_height"
        
        echo "  ${titles[i]} â†’ Position ${target_x}Ã—${target_y} (${target_width}Ã—${target_height})"
    done
    
    echo "âœ“ Window positions reverse cycled successfully"
}

# Workspace profile functions
save_workspace_profile() {
    local profile_name="$1"
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    local profile_file="$profiles_dir/$profile_name.profile"
    
    # Create profiles directory if it doesn't exist
    mkdir -p "$profiles_dir"
    
    # Get current workspace
    local current_ws
    current_ws=$(xdotool get_desktop)
    
    echo "Saving workspace profile: $profile_name"
    echo "Current workspace: $current_ws"
    
    # Clear existing profile
    > "$profile_file"
    
    # Save workspace number
    echo "WORKSPACE=$current_ws" >> "$profile_file"
    echo "" >> "$profile_file"
    
    # Get all visible windows on current workspace
    local windows
    windows=$(wmctrl -l | awk -v ws="$current_ws" '$2 == ws {print $1}' | grep -v '^$')
    
    if [[ -z "$windows" ]]; then
        echo "No windows found on current workspace"
        rm -f "$profile_file"
        return 1
    fi
    
    local window_count=0
    echo "# Window layout for workspace $current_ws" >> "$profile_file"
    
    while read -r window_id; do
        if [[ -n "$window_id" ]]; then
            # Get window geometry and title
            local geom
            geom=$(xdotool getwindowgeometry --shell "$window_id" 2>/dev/null)
            
            if [[ -n "$geom" ]]; then
                eval "$geom"
                local title
                title=$(xdotool getwindowname "$window_id" 2>/dev/null | sed 's/["\]/\\&/g')
                
                echo "# Window: $title" >> "$profile_file"
                echo "WINDOW_${window_count}_ID=$window_id" >> "$profile_file"
                echo "WINDOW_${window_count}_X=$X" >> "$profile_file"
                echo "WINDOW_${window_count}_Y=$Y" >> "$profile_file"
                echo "WINDOW_${window_count}_WIDTH=$WIDTH" >> "$profile_file"
                echo "WINDOW_${window_count}_HEIGHT=$HEIGHT" >> "$profile_file"
                echo "WINDOW_${window_count}_TITLE=\"$title\"" >> "$profile_file"
                echo "" >> "$profile_file"
                
                ((window_count++))
            fi
        fi
    done <<< "$windows"
    
    echo "WINDOW_COUNT=$window_count" >> "$profile_file"
    
    echo "âœ“ Saved $window_count windows to profile: $profile_name"
    echo "Profile saved to: $profile_file"
}

load_workspace_profile() {
    local profile_name="$1"
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    local profile_file="$profiles_dir/$profile_name.profile"
    
    if [[ ! -f "$profile_file" ]]; then
        echo "Error: Profile '$profile_name' not found"
        echo "Available profiles:"
        list_workspace_profiles
        return 1
    fi
    
    echo "Loading workspace profile: $profile_name"
    
    # Source the profile
    source "$profile_file"
    
    local loaded_count=0
    local applied_count=0
    
    for ((i=0; i<WINDOW_COUNT; i++)); do
        local id_var="WINDOW_${i}_ID"
        local x_var="WINDOW_${i}_X"
        local y_var="WINDOW_${i}_Y"
        local width_var="WINDOW_${i}_WIDTH"
        local height_var="WINDOW_${i}_HEIGHT"
        local title_var="WINDOW_${i}_TITLE"
        
        local window_id="${!id_var:-}"
        local x="${!x_var:-}"
        local y="${!y_var:-}"
        local width="${!width_var:-}"
        local height="${!height_var:-}"
        local title="${!title_var:-}"
        
        if [[ -n "$window_id" && -n "$x" && -n "$y" && -n "$width" && -n "$height" ]]; then
            ((loaded_count++))
            
            # Check if window still exists
            if xdotool windowmap "$window_id" 2>/dev/null; then
                # Position the window
                xdotool windowmove "$window_id" "$x" "$y"
                xdotool windowsize "$window_id" "$width" "$height"
                ((applied_count++))
                echo "âœ“ Positioned: $title"
            else
                echo "âš  Window no longer exists: $title"
            fi
        fi
    done
    
    echo ""
    echo "Profile loaded: $profile_name"
    echo "Windows loaded: $loaded_count"
    echo "Windows positioned: $applied_count"
}

list_workspace_profiles() {
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    
    if [[ ! -d "$profiles_dir" ]]; then
        echo "No workspace profiles found"
        echo "Create profiles with: place-window workspace save <name>"
        return
    fi
    
    local profiles
    profiles=$(find "$profiles_dir" -name "*.profile" -type f 2>/dev/null | sort)
    
    if [[ -z "$profiles" ]]; then
        echo "No workspace profiles found"
        echo "Create profiles with: place-window workspace save <name>"
        return
    fi
    
    echo "Available workspace profiles:"
    
    while read -r profile_file; do
        if [[ -n "$profile_file" ]]; then
            local profile_name
            profile_name=$(basename "$profile_file" .profile)
            
            # Get profile info
            local workspace_num window_count
            workspace_num=$(grep "^WORKSPACE=" "$profile_file" | cut -d= -f2)
            window_count=$(grep "^WINDOW_COUNT=" "$profile_file" | cut -d= -f2)
            
            echo "  $profile_name (workspace $workspace_num, $window_count windows)"
        fi
    done <<< "$profiles"
}

delete_workspace_profile() {
    local profile_name="$1"
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    local profile_file="$profiles_dir/$profile_name.profile"
    
    if [[ ! -f "$profile_file" ]]; then
        echo "Error: Profile '$profile_name' not found"
        list_workspace_profiles
        return 1
    fi
    
    echo "Deleting workspace profile: $profile_name"
    rm -f "$profile_file"
    echo "âœ“ Profile deleted"
}

# Meta-layout functions (work with any number of windows)
apply_meta_maximize() {
    get_screen_info
    local visible_windows=()
    
    # Get all visible windows across all monitors
    for monitor in "${MONITORS[@]}"; do
        local window_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && window_list+=("$line")
        done < <(get_visible_windows_on_monitor "$monitor")
        visible_windows+=("${window_list[@]}")
    done
    
    if [[ ${#visible_windows[@]} -eq 0 ]]; then
        echo "No visible windows found"
        return
    fi
    
    echo "Found ${#visible_windows[@]} visible window(s)"
    echo "Maximizing first window: $(xdotool getwindowname "${visible_windows[0]}" 2>/dev/null || echo "Window ${visible_windows[0]}")"
    
    # Maximize first window using its current monitor
    local first_window="${visible_windows[0]}"
    local target_monitor=$(get_window_monitor "$first_window")
    local layout_area=$(get_monitor_layout_area "$target_monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local gap=$GAP
    local final_x=$((usable_x + gap))
    local final_y=$((usable_y + gap))
    local final_w=$((usable_w - gap * 2 - decoration_w))
    local final_h=$((usable_h - gap * 2))
    apply_geometry "$first_window" $final_x $final_y $final_w $final_h
    
    # Minimize all other windows
    for ((i=1; i<${#visible_windows[@]}; i++)); do
        local window_id="${visible_windows[i]}"
        echo "Minimizing: $(xdotool getwindowname "$window_id" 2>/dev/null || echo "Window $window_id")"
        xdotool windowminimize "$window_id" 2>/dev/null
    done
}

apply_meta_columns() {
    get_screen_info
    
    # Apply columns layout to each monitor independently
    for monitor in "${MONITORS[@]}"; do
        local window_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && window_list+=("$line")
        done < <(get_visible_windows_on_monitor "$monitor")
        
        if [[ ${#window_list[@]} -eq 0 ]]; then
            continue
        fi
        
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        echo "Monitor $name: Arranging ${#window_list[@]} window(s) in columns"
        
        local layout_area=$(get_monitor_layout_area "$monitor")
        IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
        
        local gap=$GAP
        local final_x=$((usable_x + gap))
        local final_y=$((usable_y + gap))
        local final_w=$((usable_w - gap * 2 - decoration_w))
        local final_h=$((usable_h - gap * 2))
        
        local num_windows=${#window_list[@]}
        local available_w=$((final_w - gap * (num_windows - 1)))
        local column_w=$((available_w / num_windows))
        
        for ((i=0; i<num_windows; i++)); do
            local x=$((final_x + i * (column_w + gap)))
            apply_geometry "${window_list[i]}" $x $final_y $column_w $final_h
        done
    done
    
    echo "Columns meta-layout applied successfully"
}

apply_meta_rows() {
    get_screen_info
    
    # Apply rows layout to each monitor independently  
    for monitor in "${MONITORS[@]}"; do
        local window_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && window_list+=("$line")
        done < <(get_visible_windows_on_monitor "$monitor")
        
        if [[ ${#window_list[@]} -eq 0 ]]; then
            continue
        fi
        
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        echo "Monitor $name: Arranging ${#window_list[@]} window(s) in rows"
        
        local layout_area=$(get_monitor_layout_area "$monitor")
        IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
        
        local gap=$GAP
        local final_x=$((usable_x + gap))
        local final_y=$((usable_y + gap))
        local final_w=$((usable_w - gap * 2 - decoration_w))
        local final_h=$((usable_h - gap * 2))
        
        local num_windows=${#window_list[@]}
        local available_h=$((final_h - gap * 4 * (num_windows - 1)))  # Use 4x gap for safety
        local row_h=$((available_h / num_windows))
        
        for ((i=0; i<num_windows; i++)); do
            local y=$((final_y + i * (row_h + gap * 4)))  # Use 4x gap between rows
            apply_geometry "${window_list[i]}" $final_x $y $final_w $row_h
        done
    done
    
    echo "Rows meta-layout applied successfully"
}

apply_meta_grid() {
    get_screen_info
    
    # Apply grid layout to each monitor independently
    for monitor in "${MONITORS[@]}"; do
        local window_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && window_list+=("$line")
        done < <(get_visible_windows_on_monitor "$monitor")
        
        if [[ ${#window_list[@]} -eq 0 ]]; then
            continue
        fi
        
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        local num_windows=${#window_list[@]}
        
        # Calculate optimal grid dimensions
        local cols=$(( (num_windows + 1) / 2 ))  # Round up: 1â†’1, 2â†’1, 3â†’2, 4â†’2, 5â†’3, etc.
        local rows=$(( (num_windows + cols - 1) / cols ))  # Round up to fit all windows
        
        echo "Monitor $name: Arranging $num_windows window(s) in ${cols}Ã—${rows} grid"
        
        local layout_area=$(get_monitor_layout_area "$monitor")
        IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
        
        local gap=$GAP
        local decoration_h=$DECORATION_HEIGHT
    local decoration_w=$DECORATION_WIDTH
        
        # Account for decorations and gaps - top-down positioning
        local available_w=$((usable_w - gap * (cols + 1)))  # Left, right, and between columns
        local available_h=$((usable_h - gap * (rows + 1) - decoration * rows))  # Top, bottom, between rows, and decorations
        local cell_w=$((available_w / cols))
        local cell_h=$((available_h / rows))
        
        for ((i=0; i<num_windows; i++)); do
            local col=$((i % cols))
            local row=$((i / cols))
            local x=$((usable_x + gap + col * (cell_w + gap)))
            local y=$((usable_y + gap + row * (cell_h + gap)))
            apply_geometry "${window_list[i]}" $x $y $cell_w $cell_h
        done
    done
    
    echo "Grid meta-layout applied successfully"
}

apply_meta_center_sidebar() {
    local center_width_percent="$1"
    get_screen_info
    
    # Apply center-sidebar layout to each monitor independently
    for monitor in "${MONITORS[@]}"; do
        local window_list=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && window_list+=("$line")
        done < <(get_visible_windows_on_monitor "$monitor")
        
        if [[ ${#window_list[@]} -eq 0 ]]; then
            continue
        fi
        
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        local num_windows=${#window_list[@]}
        echo "Monitor $name: Center-sidebar-$center_width_percent with $num_windows window(s)"
        
        if [[ $num_windows -eq 1 ]]; then
            # Only one window - use maximize atomic function
            apply_meta_maximize_single_monitor "$monitor" "${window_list[@]}"
            continue
        fi
        
        if [[ $num_windows -eq 2 ]]; then
            # Two windows - use main-sidebar atomic function with specified percentage
            apply_meta_main_sidebar_single_monitor "$monitor" "$center_width_percent" "${window_list[@]}"
            continue
        fi
        
        # For 3+ windows, create the proper center-sidebar layout:
        # Left sidebar: (100-X)/2 width | Center: X% width | Right sidebar: (100-X)/2 width
        local layout_area=$(get_monitor_layout_area "$monitor")
        IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
        
        local gap=$GAP
        local decoration_h=$DECORATION_HEIGHT
        local decoration_w=$DECORATION_WIDTH
        local final_x=$((usable_x + gap))
        local final_y=$((usable_y + gap))
        local final_w=$((usable_w - gap * 2 - decoration_w))
        local final_h=$((usable_h - gap * 2 - decoration_h))
        
        # Calculate three-column widths with gaps between them
        local gap_between=$((gap + decoration_w))  # Gap + decoration between columns
        local available_w=$((final_w - gap_between * 2))  # Total width minus 2 gaps between columns
        local center_w=$((available_w * center_width_percent / 100))
        local sidebar_total_w=$((available_w - center_w))
        local sidebar_w=$((sidebar_total_w / 2))
        
        # Calculate column positions
        local left_sidebar_x=$final_x
        local center_x=$((final_x + sidebar_w + gap_between))
        local right_sidebar_x=$((center_x + center_w + gap_between))
        
        # Position center window (first window)
        apply_geometry "${window_list[0]}" $center_x $final_y $center_w $final_h
        
        # Distribute remaining windows between left and right sidebars
        local sidebar_windows=$((num_windows - 1))
        local left_sidebar_count=$((sidebar_windows / 2))
        local right_sidebar_count=$((sidebar_windows - left_sidebar_count))
        
        # Position left sidebar windows (stacked vertically)
        if [[ $left_sidebar_count -gt 0 ]]; then
            local gap_vertical=$((gap + decoration_h))  # Gap + decoration between stacked windows
            local available_sidebar_h=$((final_h - gap_vertical * (left_sidebar_count - 1)))
            local left_sidebar_h=$((available_sidebar_h / left_sidebar_count))
            for ((i=1; i<=left_sidebar_count; i++)); do
                local y=$((final_y + (i - 1) * (left_sidebar_h + gap_vertical)))
                apply_geometry "${window_list[i]}" $left_sidebar_x $y $sidebar_w $left_sidebar_h
            done
        fi
        
        # Position right sidebar windows (stacked vertically)  
        if [[ $right_sidebar_count -gt 0 ]]; then
            local gap_vertical=$((gap + decoration_h))  # Gap + decoration between stacked windows
            local available_sidebar_h=$((final_h - gap_vertical * (right_sidebar_count - 1)))
            local right_sidebar_h=$((available_sidebar_h / right_sidebar_count))
            for ((i=0; i<right_sidebar_count; i++)); do
                local window_idx=$((left_sidebar_count + 1 + i))
                local y=$((final_y + i * (right_sidebar_h + gap_vertical)))
                apply_geometry "${window_list[window_idx]}" $right_sidebar_x $y $sidebar_w $right_sidebar_h
            done
        fi
    done
    
    echo "Center-sidebar-$center_width_percent meta-layout applied successfully"
}

# Watch daemon functions
watch_daemon() {
    # Start the daemon in the background
    exec "$0" watch daemon &
    local daemon_pid=$!
    echo "Watch daemon started (PID: $daemon_pid)"
    
    # Wait for the daemon process
    wait $daemon_pid
}

watch_daemon_internal() {
    # Efficient event-driven daemon - monitors key X11 properties to avoid process explosion
    echo "$(date): Efficient event-driven watch daemon started"
    echo "$(date): Using combined monitoring approach to prevent resource exhaustion"
    
    # Trap signals for clean exit
    local monitor_pids=()
    trap 'echo "Watch daemon stopped"; for pid in "${monitor_pids[@]}"; do kill $pid 2>/dev/null; done; exit 0' SIGINT SIGTERM
    
    # Function to apply layout when window state changes
    apply_workspace_layout() {
        local trigger_reason="$1"
        
        local current_workspace
        current_workspace=$(xdotool get_desktop 2>/dev/null || echo "0")
        
        local workspace_layout
        workspace_layout=$(get_workspace_meta_layout "$current_workspace" 2>/dev/null)
        
        # If no layout set for workspace, use "auto" as fallback
        if [[ -z "$workspace_layout" ]]; then
            workspace_layout="auto"
        fi
        
        echo "$(date): $trigger_reason - applying layout '$workspace_layout' to workspace $current_workspace"
        
        # Small delay to ensure window changes are complete
        sleep 0.2
        
        # Parse layout command properly for meta layouts
        if [[ "$workspace_layout" =~ ^meta[[:space:]](.+)$ ]]; then
            # Meta layout - split into separate arguments
            local meta_command="${BASH_REMATCH[1]}"
            echo "$(date): Executing meta layout: $meta_command"
            "$0" meta "$meta_command"
        else
            # Regular layout command
            echo "$(date): Executing regular layout: $workspace_layout"
            "$0" "$workspace_layout"
        fi
    }
    
    echo "$(date): Starting efficient X11 property monitoring"
    
    # Monitor window creation/destruction with _NET_CLIENT_LIST
    echo "$(date): Monitoring window creation/destruction events"
    xprop -spy -root _NET_CLIENT_LIST 2>/dev/null | while IFS= read -r line; do
        if [[ -n "$line" && "$line" =~ _NET_CLIENT_LIST ]]; then
            echo "$(date): Window list changed (create/destroy)"
            apply_workspace_layout "Window list change"
        fi
    done &
    
    local client_list_pid=$!
    monitor_pids+=($client_list_pid)
    
    # Monitor window minimize/restore with _NET_CLIENT_LIST_STACKING
    echo "$(date): Monitoring window stacking/state events"
    xprop -spy -root _NET_CLIENT_LIST_STACKING 2>/dev/null | while IFS= read -r line; do
        if [[ -n "$line" && "$line" =~ _NET_CLIENT_LIST_STACKING ]]; then
            echo "$(date): Window stacking changed (minimize/restore/reorder)"
            
            # Brief delay to avoid rapid-fire during multi-window operations
            sleep 0.1
            apply_workspace_layout "Window stacking change"
        fi
    done &
    
    local stacking_pid=$!
    monitor_pids+=($stacking_pid)
    
    # Optional: Monitor workspace changes if supported
    if xprop -root _NET_CURRENT_DESKTOP >/dev/null 2>&1; then
        echo "$(date): Monitoring workspace changes"
        xprop -spy -root _NET_CURRENT_DESKTOP 2>/dev/null | while IFS= read -r line; do
            if [[ -n "$line" && "$line" =~ _NET_CURRENT_DESKTOP ]]; then
                echo "$(date): Workspace changed"
                # Small delay to let workspace switch complete
                sleep 0.3
                apply_workspace_layout "Workspace change"
            fi
        done &
        
        local workspace_pid=$!
        monitor_pids+=($workspace_pid)
    fi
    
    echo "$(date): Event-driven daemon initialized with ${#monitor_pids[@]} monitoring processes"
    echo "$(date): Maximum resource usage: ${#monitor_pids[@]} background processes (vs potentially 100s with per-window monitoring)"
    
    # Wait for all monitoring processes
    wait
}

# Main logic
case "${1:-}" in
    "")
        # No arguments - interactive mode
        interactive_mode
        ;;
    ul|ur|ll|lr|c|left|right|top|bottom|maximize)
        # Preset layout
        id=$(pick_window)
        apply_preset "$1" "$id"
        ;;
    ws)
        # Move to workspace
        if [[ -z "${2:-}" ]]; then
            echo "Error: Workspace number required"
            exit 1
        fi
        id=$(pick_window)
        move_to_workspace "$id" "$2"
        ;;
    save)
        # Save current position
        if [[ -z "${2:-}" ]]; then
            echo "Error: Position name required"
            exit 1
        fi
        id=$(pick_window)
        save_position "$2" "$id"
        ;;
    load)
        # Load saved position
        if [[ -z "${2:-}" ]]; then
            echo "Error: Position name required"
            exit 1
        fi
        id=$(pick_window)
        load_position "$2" "$id"
        ;;
    list)
        # List saved presets
        echo "Available presets:"
        grep -v '^#' "$PRESETS_FILE" | cut -d= -f1 | sed 's/^/  - /'
        ;;
    monitors)
        # Show monitor information
        get_screen_info
        echo "Screen Resolution: ${SCREEN_W:-Unknown}x${SCREEN_H:-Unknown}"
        echo "Detected Monitors:"
        for i in "${!MONITORS[@]}"; do
            IFS=':' read -r name mx my mw mh <<< "${MONITORS[i]}"
            echo "  Monitor $((i+1)): $name (${mw}x${mh}+${mx}+${my})"
            
            layout_area=$(get_monitor_layout_area "${MONITORS[i]}")
            IFS=':' read -r ux uy uw uh <<< "$layout_area"
            echo "    Usable area: ${uw}x${uh}+${ux}+${uy} (with gaps)"
        done
        
        if [[ ${#MONITORS[@]} -gt 1 ]]; then
            echo ""
            echo "Multi-monitor features:"
            echo "- Windows positioned on their current monitor"
            echo "- Panel height applied only to primary monitor"
            echo "- Auto-layout groups windows per monitor"
        fi
        ;;
    auto)
        # Auto-layout all visible windows
        auto_layout
        save_workspace_meta_layout "$(get_current_workspace)" "auto"
        ;;
    resize)
        # Simultaneous resize with adjacent windows
        case "${2:-}" in
            expand-right|shrink-right|expand-down|shrink-down)
                simultaneous_resize "$2" "${3:-50}"
                ;;
            *)
                echo "Resize commands:"
                echo "  place-window resize expand-right [pixels]   Expand right, shrink adjacent"
                echo "  place-window resize shrink-right [pixels]   Shrink right, expand adjacent"
                echo "  place-window resize expand-down [pixels]    Expand down, shrink adjacent"
                echo "  place-window resize shrink-down [pixels]    Shrink down, expand adjacent"
                echo ""
                echo "Default resize amount: 50 pixels"
                ;;
        esac
        ;;
    master)
        # Master-stack layouts
        case "${2:-}" in
            vertical|horizontal)
                # Check if third parameter is a percentage
                percentage="${3:-60}"
                if [[ "$percentage" =~ ^[0-9]+$ && $percentage -ge 10 && $percentage -le 90 ]]; then
                    master_stack_layout "$2" "$percentage"
                else
                    if [[ -n "$3" ]]; then
                        echo "Error: Percentage must be 10-90"
                        echo "Usage: place-window master vertical [10-90]"
                        exit 1
                    fi
                    master_stack_layout "$2" 60  # Default 60%
                fi
                ;;
            center)
                # Check if third parameter is a percentage
                percentage="${3:-50}"
                if [[ "$percentage" =~ ^[0-9]+$ && $percentage -ge 10 && $percentage -le 90 ]]; then
                    apply_meta_center_sidebar "$percentage"
                    save_workspace_meta_layout "$(get_current_workspace)" "master center-${percentage}"
                else
                    if [[ -n "$3" ]]; then
                        echo "Error: Percentage must be 10-90"
                        echo "Usage: place-window master center [10-90]"
                        exit 1
                    fi
                    apply_meta_center_sidebar 50  # Default 50%
                    save_workspace_meta_layout "$(get_current_workspace)" "master center-50"
                fi
                ;;
            *)
                echo "Master layouts:"
                echo "  place-window master vertical [percentage]    Master left, stack right"
                echo "  place-window master horizontal [percentage]  Master top, stack bottom"
                echo "  place-window master center [percentage]      Center master, side stacks"
                echo ""
                echo "Examples:"
                echo "  place-window master vertical      # 60% master (default)"
                echo "  place-window master vertical 70   # 70% master, 30% stack"
                echo "  place-window master horizontal 50 # 50% master, 50% stack"
                echo "  place-window master center        # 50% center (default)"
                echo "  place-window master center 60     # 60% center, 20% each side"
                ;;
        esac
        ;;
    focus)
        # Focus navigation
        case "${2:-}" in
            next|prev|up|down|left|right)
                focus_window "$2"
                ;;
            *)
                echo "Focus navigation:"
                echo "  place-window focus next     Focus next window"
                echo "  place-window focus prev     Focus previous window"
                echo "  place-window focus up       Focus window above"
                echo "  place-window focus down     Focus window below"
                echo "  place-window focus left     Focus window to the left"
                echo "  place-window focus right    Focus window to the right"
                ;;
        esac
        ;;
    auto-config)
        # Configure auto-layout preferences
        case "${2:-}" in
            1|2|3|4|5)
                local window_count="$2"
                local layout="${3:-}"
                case $window_count in
                    1)
                        if [[ -z "$layout" ]]; then
                            echo "Current 1-window layout: ${AUTO_LAYOUT_1:-maximize}"
                            echo "Available: maximize"
                        else
                            sed -i "s/^AUTO_LAYOUT_1=.*/AUTO_LAYOUT_1=\"$layout\"/" "$SETTINGS_FILE"
                            echo "1-window layout set to: $layout"
                        fi
                        ;;
                    2)
                        if [[ -z "$layout" ]]; then
                            echo "Current 2-window layout: ${AUTO_LAYOUT_2:-equal}"
                            echo "Available: equal, primary-secondary, secondary-primary"
                        else
                            sed -i "s/^AUTO_LAYOUT_2=.*/AUTO_LAYOUT_2=\"$layout\"/" "$SETTINGS_FILE"
                            echo "2-window layout set to: $layout"
                        fi
                        ;;
                    3)
                        if [[ -z "$layout" ]]; then
                            echo "Current 3-window layout: ${AUTO_LAYOUT_3:-main-two-side}"
                            echo "Available: main-two-side, three-columns, center-sidebars"
                        else
                            sed -i "s/^AUTO_LAYOUT_3=.*/AUTO_LAYOUT_3=\"$layout\"/" "$SETTINGS_FILE"
                            echo "3-window layout set to: $layout"
                        fi
                        ;;
                    4)
                        if [[ -z "$layout" ]]; then
                            echo "Current 4-window layout: ${AUTO_LAYOUT_4:-grid}"
                            echo "Available: grid, main-three-side, three-top-bottom"
                        else
                            sed -i "s/^AUTO_LAYOUT_4=.*/AUTO_LAYOUT_4=\"$layout\"/" "$SETTINGS_FILE"
                            echo "4-window layout set to: $layout"
                        fi
                        ;;
                    5)
                        if [[ -z "$layout" ]]; then
                            echo "Current 5-window layout: ${AUTO_LAYOUT_5:-grid-wide-bottom}"
                            echo "Available: center-corners, two-three-columns, grid-wide-bottom"
                        else
                            sed -i "s/^AUTO_LAYOUT_5=.*/AUTO_LAYOUT_5=\"$layout\"/" "$SETTINGS_FILE"
                            echo "5-window layout set to: $layout"
                        fi
                        ;;
                esac
                ;;
            show)
                echo "Auto-layout preferences:"
                echo "  1 window:  ${AUTO_LAYOUT_1:-maximize}"
                echo "  2 windows: ${AUTO_LAYOUT_2:-equal}"
                echo "  3 windows: ${AUTO_LAYOUT_3:-main-two-side}"
                echo "  4 windows: ${AUTO_LAYOUT_4:-grid}"
                echo "  5 windows: ${AUTO_LAYOUT_5:-grid-wide-bottom}"
                ;;
            *)
                echo "Auto-layout configuration:"
                echo "  place-window auto-config show              Show current preferences"
                echo "  place-window auto-config 1 [layout]        Set/show 1-window layout"
                echo "  place-window auto-config 2 [layout]        Set/show 2-window layout"
                echo "  place-window auto-config 3 [layout]        Set/show 3-window layout"
                echo "  place-window auto-config 4 [layout]        Set/show 4-window layout"
                echo "  place-window auto-config 5 [layout]        Set/show 5-window layout"
                echo ""
                echo "Available layouts:"
                echo "  1 window:  maximize"
                echo "  2 windows: equal, primary-secondary, secondary-primary"
                echo "  3 windows: main-two-side, three-columns, center-sidebars"
                echo "  4 windows: grid, main-three-side, three-top-bottom"
                echo "  5 windows: center-corners, two-three-columns, grid-wide-bottom"
                ;;
        esac
        ;;
    watch)
        # Watch mode for automatic window tiling
        case "${2:-}" in
            start)
                if pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    echo "Watch mode already running (PID: $(pgrep -f "place-window.*watch.*daemon"))"
                    exit 1
                fi
                echo "Starting watch mode daemon..."
                echo "Monitoring for new windows and automatically applying tiling layouts"
                echo "Press Ctrl+C to stop"
                echo ""
                
                # Start the watch daemon
                watch_daemon
                ;;
            stop)
                if ! pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    echo "Watch mode is not running"
                    exit 1
                fi
                
                echo "Stopping watch mode daemon..."
                pkill -f "place-window.*watch.*daemon"
                echo "Watch mode stopped"
                ;;
            status)
                if pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    echo "Watch mode is running (PID: $(pgrep -f "place-window.*watch.*daemon"))"
                else
                    echo "Watch mode is not running"
                fi
                ;;
            toggle)
                if pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    # Watch mode is running, stop it
                    echo "Watch mode is running - stopping..."
                    pkill -f "place-window.*watch.*daemon"
                    echo "Watch mode stopped"
                else
                    # Watch mode is not running, start it in background
                    echo "Starting watch mode daemon..."
                    exec "$0" watch daemon &
                    daemon_pid=$!
                    echo "Watch daemon started in background (PID: $daemon_pid)"
                    echo "Use 'place-window watch stop' to stop it"
                fi
                ;;
            daemon)
                # Internal daemon mode - do not call directly
                watch_daemon_internal
                ;;
            *)
                echo "Watch mode commands:"
                echo "  place-window watch start    Start automatic tiling daemon"
                echo "  place-window watch stop     Stop the daemon"
                echo "  place-window watch status   Check daemon status"
                echo "  place-window watch toggle   Toggle daemon on/off"
                echo ""
                echo "Watch mode automatically applies the last-used layout per workspace"
                echo "when windows are created, minimized, or maximized"
                ;;
        esac
        ;;
    meta)
        # Meta-layouts that work with any number of windows
        case "${2:-}" in
            maximize)
                echo "Applying maximize meta-layout: Top window maximized, others minimized"
                apply_meta_maximize
                save_workspace_meta_layout "$(get_current_workspace)" "meta maximize"
                ;;
            columns)
                echo "Applying columns meta-layout: All windows in equal columns"
                apply_meta_columns
                save_workspace_meta_layout "$(get_current_workspace)" "meta columns"
                ;;
            rows)
                echo "Applying rows meta-layout: All windows in equal rows"
                apply_meta_rows
                save_workspace_meta_layout "$(get_current_workspace)" "meta rows"
                ;;
            grid)
                echo "Applying grid meta-layout: Dynamic grid based on window count"
                apply_meta_grid
                save_workspace_meta_layout "$(get_current_workspace)" "meta grid"
                ;;
            *)
                echo "Meta-layout commands (work with any number of windows):"
                echo "  place-window meta maximize          Maximize top window, minimize others"
                echo "  place-window meta columns           Distribute all windows in columns"
                echo "  place-window meta rows              Distribute all windows in rows"
                echo "  place-window meta grid              Dynamic grid layout"
                echo ""
                echo "Examples:"
                echo "  place-window meta columns           # 5 windows = 5 columns"
                echo "  place-window meta grid              # 5 windows = 3Ã—2 grid"
                ;;
        esac
        ;;
    workspace)
        # Workspace layout status and management
        case "${2:-}" in
            status)
                current_workspace=$(get_current_workspace)
                current_layout=$(get_workspace_meta_layout "$current_workspace")
                echo "Current workspace: $current_workspace"
                echo "Layout: $current_layout"
                ;;
            *)
                echo "Workspace commands:"
                echo "  place-window workspace status    Show current workspace and layout"
                ;;
        esac
        ;;
    swap)
        # Window swapping functionality
        case "${2:-}" in
            drag)
                echo "Drag-to-swap mode: Click and drag a window to swap with another"
                echo "Step 1: Click on the first window to start drag mode"
                drag_swap_windows
                ;;
            interactive)
                echo "Interactive swap: Click two windows to swap their positions"
                interactive_swap_windows
                ;;
            cycle)
                echo "Cycling all window positions clockwise..."
                cycle_window_positions
                ;;
            reverse)
                echo "Cycling all window positions counter-clockwise..."
                reverse_cycle_window_positions
                ;;
            *)
                echo "Window swap commands:"
                echo "  place-window swap drag          Drag-to-swap mode (click and drag)"
                echo "  place-window swap interactive   Click two windows to swap positions"
                echo "  place-window swap cycle         Rotate all windows clockwise"
                echo "  place-window swap reverse       Rotate all windows counter-clockwise"
                echo ""
                echo "Swap functionality allows you to exchange positions of two windows,"
                echo "or cycle/rotate all visible windows through their positions"
                ;;
        esac
        ;;
    workspace)
        # Workspace-specific configuration commands
        case "${2:-}" in
            save)
                if [[ -z "${3:-}" ]]; then
                    echo "Error: Profile name required"
                    echo "Usage: place-window workspace save <profile-name>"
                    exit 1
                fi
                save_workspace_profile "$3"
                ;;
            load)
                if [[ -z "${3:-}" ]]; then
                    echo "Error: Profile name required"
                    echo "Usage: place-window workspace load <profile-name>"
                    exit 1
                fi
                load_workspace_profile "$3"
                ;;
            list)
                list_workspace_profiles
                ;;
            delete)
                if [[ -z "${3:-}" ]]; then
                    echo "Error: Profile name required"
                    echo "Usage: place-window workspace delete <profile-name>"
                    exit 1
                fi
                delete_workspace_profile "$3"
                ;;
            *)
                echo "Workspace profile commands:"
                echo "  place-window workspace save <name>     Save current workspace layout"
                echo "  place-window workspace load <name>     Load saved workspace layout"
                echo "  place-window workspace list            List all saved profiles"
                echo "  place-window workspace delete <name>   Delete a profile"
                echo ""
                echo "Workspace profiles save the position and layout of all windows"
                echo "on the current workspace, allowing you to restore entire layouts"
                ;;
        esac
        ;;
    config)
        # Configuration commands
        case "${2:-}" in
            gap)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" =~ ^[0-9]+$ ]]; then
                        sed -i "s/^GAP=.*/GAP=$3/" "$SETTINGS_FILE"
                        echo "Gap size set to ${3}px"
                    else
                        echo "Error: Gap size must be a number"
                        exit 1
                    fi
                else
                    echo "Current gap size: ${GAP}px"
                fi
                ;;
            panel)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" =~ ^[0-9]+$ ]]; then
                        sed -i "s/^PANEL_HEIGHT=.*/PANEL_HEIGHT=$3/" "$SETTINGS_FILE"
                        echo "Panel height set to ${3}px"
                    else
                        echo "Error: Panel height must be a number"
                        exit 1
                    fi
                else
                    echo "Current panel height: ${PANEL_HEIGHT}px"
                fi
                ;;
            autohide)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" == "true" || "$3" == "false" ]]; then
                        sed -i "s/^PANEL_AUTOHIDE=.*/PANEL_AUTOHIDE=$3/" "$SETTINGS_FILE"
                        echo "Panel auto-hide set to: $3"
                        if [[ "$3" == "true" ]]; then
                            echo "Panel height will be ignored for layout calculations"
                        else
                            echo "Panel height (${PANEL_HEIGHT}px) will be reserved at top"
                        fi
                    else
                        echo "Error: Panel auto-hide must be 'true' or 'false'"
                        exit 1
                    fi
                else
                    echo "Panel auto-hide mode: ${PANEL_AUTOHIDE}"
                fi
                ;;
            decoration-height)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" =~ ^[0-9]+$ ]]; then
                        sed -i "s/^DECORATION_HEIGHT=.*/DECORATION_HEIGHT=$3/" "$SETTINGS_FILE"
                        echo "Window decoration height set to ${3}px"
                    else
                        echo "Error: Decoration height must be a number"
                        exit 1
                    fi
                else
                    echo "Current decoration height: ${DECORATION_HEIGHT}px"
                fi
                ;;
            decoration-width)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" =~ ^[0-9]+$ ]]; then
                        sed -i "s/^DECORATION_WIDTH=.*/DECORATION_WIDTH=$3/" "$SETTINGS_FILE"
                        echo "Window decoration width set to ${3}px"
                    else
                        echo "Error: Decoration width must be a number"
                        exit 1
                    fi
                else
                    echo "Current decoration width: ${DECORATION_WIDTH}px"
                fi
                ;;
            decoration-detect)
                auto_detect_decorations
                ;;
            show)
                echo "Current settings:"
                echo "  Gap: ${GAP}px"
                echo "  Panel height: ${PANEL_HEIGHT}px"
                echo "  Panel auto-hide: ${PANEL_AUTOHIDE}"
                echo "  Decoration height: ${DECORATION_HEIGHT}px"
                echo "  Decoration width: ${DECORATION_WIDTH}px"
                echo "  Min window width: ${MIN_WIDTH}px"
                echo "  Min window height: ${MIN_HEIGHT}px"
                echo ""
                echo "Auto-layout preferences:"
                echo "  1 window:  ${AUTO_LAYOUT_1:-maximize}"
                echo "  2 windows: ${AUTO_LAYOUT_2:-equal}"
                echo "  3 windows: ${AUTO_LAYOUT_3:-main-two-side}"
                echo "  4 windows: ${AUTO_LAYOUT_4:-grid}"
                echo "  5 windows: ${AUTO_LAYOUT_5:-grid-wide-bottom}"
                echo ""
                echo "Configuration file: $SETTINGS_FILE"
                ;;
            *)
                echo "Configuration commands:"
                echo "  place-window config gap [SIZE]     Set or show gap size"
                echo "  place-window config panel [SIZE]   Set or show panel height"
                echo "  place-window config autohide [true/false]  Set panel auto-hide mode"
                echo "  place-window config decoration-height [SIZE]  Set or show window decoration height"
                echo "  place-window config decoration-width [SIZE]   Set or show window decoration width"
                echo "  place-window config show           Show all settings"
                ;;
        esac
        ;;
    help|--help|-h)
        cat << 'EOF'
Window Positioning Tool for Qubes OS dom0

Usage:
  place-window                    Interactive mode
  place-window ul|ur|ll|lr|c      Quick corner/center presets
  place-window left|right|top|bottom|maximize  Half-screen presets
  place-window auto               Auto-layout all visible windows
  place-window auto-config <N> [layout]  Configure auto-layout preferences
  place-window resize <direction> [pixels]  Simultaneous resize with adjacent windows
  place-window master <orientation>  Master-stack layouts
  place-window focus <direction>  Navigate between windows
  place-window watch <command>    Watch mode for automatic tiling
  place-window workspace <command>  Workspace-specific layout profiles
  place-window swap <mode>        Window position swapping
  place-window <X> <Y> <W> <H>    Custom geometry
  place-window ws <N>             Move to workspace N (0-based)
  place-window save <name>        Save current window position
  place-window load <name>        Load saved position
  place-window list               List all saved presets
  place-window monitors           Show monitor information
  place-window config <option>    Configuration commands
  place-window help               Show this help

Quick presets (with configurable gaps):
  ul - Upper left quarter    left - Left half
  ur - Upper right quarter   right - Right half
  ll - Lower left quarter    top - Top half
  lr - Lower right quarter   bottom - Bottom half
  c  - Center                maximize - Maximize with gaps

Auto-layout:
  place-window auto                   Arrange all visible windows automatically
  place-window auto-config show       Show current auto-layout preferences
  place-window auto-config 2 equal    Set 2-window layout to equal split
  
  Available auto-layouts:
    1 window:  maximize
    2 windows: equal, primary-secondary, secondary-primary
    3 windows: main-two-side, three-columns, center-sidebars
    4 windows: grid, main-three-side, three-top-bottom
    5 windows: center-corners, two-three-columns, grid-wide-bottom

Master layouts (xpytile-inspired):
  place-window master vertical [%]   Master left, stack right (default 60%)  
  place-window master horizontal [%] Master top, stack bottom (default 60%)
  place-window master center [%]     Center master, side stacks (default 50%)

Simultaneous resize (affects adjacent windows):
  place-window resize expand-right [pixels]   Expand right, shrink adjacent
  place-window resize shrink-right [pixels]   Shrink right, expand adjacent
  place-window resize expand-down [pixels]    Expand down, shrink adjacent
  place-window resize shrink-down [pixels]    Shrink down, expand adjacent

Focus navigation:
  place-window focus next/prev     Cycle through windows
  place-window focus up/down/left/right  Navigate geometrically

Watch mode (automatic tiling daemon):
  place-window watch start        Start automatic tiling daemon
  place-window watch stop         Stop the daemon
  place-window watch status       Check daemon status
  place-window watch toggle       Toggle daemon on/off
  
  Watch mode monitors window changes and automatically applies the last-used
  layout per workspace. Responds to window creation, minimize, and maximize.

Workspace layout profiles:
  place-window workspace save <name>     Save current workspace layout
  place-window workspace load <name>     Load saved workspace layout
  place-window workspace list           List all saved profiles
  place-window workspace delete <name>   Delete a profile
  
  Workspace profiles save the position of all windows on the current
  workspace, allowing you to restore entire multi-window layouts.

Window position swapping and rotation:
  place-window swap drag          Drag-to-swap mode (click and drag)
  place-window swap interactive   Click two windows to swap positions
  place-window swap cycle         Rotate all windows clockwise
  place-window swap reverse       Rotate all windows counter-clockwise
  
  Swap functionality allows you to exchange positions of two windows,
  or cycle/rotate all visible windows through their positions to
  reorganize your tiled layout quickly.

Configuration commands:
  place-window config gap [SIZE]     Set or show gap size (default: 10px)
  place-window config panel [SIZE]   Set or show panel height (default: 32px)
  place-window config autohide [true/false]  Panel auto-hide mode
  place-window config decoration-height [SIZE]  Set or show window decoration height
  place-window config decoration-width [SIZE]   Set or show window decoration width
  place-window config decoration-detect         Auto-detect decoration dimensions
  place-window config show           Show all current settings

Examples:
  place-window                    # Interactive menu
  place-window auto               # Auto-arrange all visible windows
  place-window watch start        # Start automatic tiling daemon
  place-window workspace save work # Save current workspace layout
  place-window swap interactive    # Swap positions of two windows
  place-window master vertical    # Master-stack with master on left (60%)
  place-window master vertical 70 # Master-stack with 70% master, 30% stack
  place-window master center 60   # Center master (60%) with 20% each side
  place-window resize expand-right 100  # Expand window right by 100px
  place-window focus right        # Focus window to the right
  place-window auto-config 2 primary-secondary  # 70/30 split for 2 windows
  place-window config gap 15      # Set 15px gaps around windows
  place-window config decoration-detect  # Auto-detect window decoration size

Gap behavior:
  - All layouts maintain the configured gap around windows
  - Gaps are applied: left, right, top, bottom, and between windows
  - Custom coordinates ignore gaps for exact positioning
  - Simultaneous resize preserves gaps between adjacent windows

Configuration files:
  Settings: ~/.config/window-positioning/settings.conf
  Presets:  ~/.config/window-positioning/presets.conf

Multi-monitor support:
  place-window monitors           Show detected monitors and layout areas
  
  Multi-monitor behavior:
  â€¢ Windows positioned within their current monitor boundaries
  â€¢ Auto-layout groups and arranges windows per monitor
  â€¢ Panel height applied only to primary monitor (usually leftmost)
  â€¢ All presets (ul, ur, etc.) work within the target monitor

Advanced Features (inspired by xpytile):
  â€¢ Simultaneous resize of adjacent windows
  â€¢ Master-stack layouts with configurable ratios
  â€¢ Geometric focus navigation
  â€¢ Auto-layout based on window count
  â€¢ Multi-monitor aware positioning
EOF
        ;;
    *[0-9]*)
        # Custom geometry (4 numbers)
        if [[ "$#" -ne 4 ]]; then
            echo "Error: Custom geometry requires 4 numbers: X Y Width Height"
            exit 1
        fi
        id=$(pick_window)
        apply_geometry "$id" "$1" "$2" "$3" "$4"
        ;;
    *)
        # Try as saved preset
        id=$(pick_window)
        apply_preset "$1" "$id"
        ;;
esac