#!/usr/bin/env bash
# place-window: Position windows in dom0 with mouse selection or window ID
# Usage:
#   place-window                  # Interactive mode
#   place-window ul|ur|ll|lr|c    # Quick presets
#   place-window <X> <Y> <W> <H>  # Custom geometry
#   place-window ws <N>           # Move to workspace N (0-based)
#   place-window save <name>      # Save current window position
#   place-window load <name>      # Load saved position

set -euo pipefail

CONFIG_DIR="${HOME}/.config/window-positioning"
PRESETS_FILE="${CONFIG_DIR}/presets.conf"
SETTINGS_FILE="${CONFIG_DIR}/settings.conf"

# Ensure config directory exists
mkdir -p "$CONFIG_DIR"

# Initialize settings file if not exists
if [[ ! -f "$SETTINGS_FILE" ]]; then
    cat > "$SETTINGS_FILE" << 'EOF'
# Window positioning settings
# Gap around windows (in pixels)
GAP=10

# Panel height (adjust for your XFCE theme)
# Set to 0 if panel auto-hides or doesn't reserve space
PANEL_HEIGHT=32

# Panel auto-hide mode
# Set to true if panel is set to auto-hide (intelligently or always)
# When true, panel height is ignored for layout calculations
PANEL_AUTOHIDE=false

# Minimum window size
MIN_WIDTH=400
MIN_HEIGHT=300

# Auto-layout preferences
# Available layouts for each window count:
# 1 window: maximize
# 2 windows: equal, primary-secondary, secondary-primary
# 3 windows: main-two-side, three-columns, center-sidebars
# 4 windows: grid, main-three-side, three-top-bottom
# 5 windows: center-corners, two-three-columns, grid-wide-bottom

AUTO_LAYOUT_1="maximize"
AUTO_LAYOUT_2="equal"
AUTO_LAYOUT_3="main-two-side"
AUTO_LAYOUT_4="grid"
AUTO_LAYOUT_5="grid-wide-bottom"
EOF
fi

# Initialize presets file if not exists
if [[ ! -f "$PRESETS_FILE" ]]; then
    cat > "$PRESETS_FILE" << 'EOF'
# Window positioning presets
# Format: NAME=X,Y,WIDTH,HEIGHT
# You can add custom presets here
browser-left=10,40,960,1040
browser-right=970,40,960,1040
terminal-top=10,40,1920,500
terminal-bottom=10,580,1920,500
editor-center=480,270,960,540
EOF
fi

# Load settings
source "$SETTINGS_FILE"

# Set defaults if not in config
GAP=${GAP:-10}
PANEL_HEIGHT=${PANEL_HEIGHT:-32}
PANEL_AUTOHIDE=${PANEL_AUTOHIDE:-false}
MIN_WIDTH=${MIN_WIDTH:-400}
MIN_HEIGHT=${MIN_HEIGHT:-300}

# Function to pick a window with mouse
pick_window() {
    echo "Click on a window to select it..." >&2
    xdotool selectwindow
}

# Function to get current window geometry
get_window_geometry() {
    local id="$1"
    xwininfo -id "$id" | awk '
        /Absolute upper-left X:/ {x=$NF}
        /Absolute upper-left Y:/ {y=$NF}
        /Width:/ {w=$NF}
        /Height:/ {h=$NF}
        END {print x","y","w","h}
    '
}

# Function to apply geometry to window
apply_geometry() {
    local id="$1" x="$2" y="$3" w="$4" h="$5"
    wmctrl -i -r "$id" -e "0,${x},${y},${w},${h}"
    echo "Window positioned at: X=$x, Y=$y, Width=$w, Height=$h"
}

# Function to move window to workspace
move_to_workspace() {
    local id="$1" ws="$2"
    wmctrl -i -r "$id" -t "$ws"
    echo "Window moved to workspace $((ws + 1))"
}

# Function to save window position
save_position() {
    local name="$1" id="$2"
    local geom=$(get_window_geometry "$id")
    
    # Remove existing entry if exists
    grep -v "^${name}=" "$PRESETS_FILE" > "${PRESETS_FILE}.tmp" || true
    mv "${PRESETS_FILE}.tmp" "$PRESETS_FILE"
    
    # Add new entry
    echo "${name}=${geom}" >> "$PRESETS_FILE"
    echo "Position saved as '$name': $geom"
}

# Function to load saved position
load_position() {
    local name="$1" id="$2"
    local geom=$(grep "^${name}=" "$PRESETS_FILE" 2>/dev/null | cut -d= -f2)
    
    if [[ -z "$geom" ]]; then
        echo "Error: Preset '$name' not found"
        echo "Available presets:"
        grep -v '^#' "$PRESETS_FILE" | cut -d= -f1 | sed 's/^/  - /'
        exit 1
    fi
    
    IFS=',' read -r x y w h <<< "$geom"
    apply_geometry "$id" "$x" "$y" "$w" "$h"
}

# Get screen and monitor information
get_screen_info() {
    # Get total screen dimensions
    xdotool getdisplaygeometry | read -r SCREEN_W SCREEN_H
    export SCREEN_W SCREEN_H
    
    # Get monitor information using xrandr
    MONITORS=()
    while IFS= read -r line; do
        if [[ $line =~ ^([^[:space:]]+)[[:space:]]+connected[[:space:]]+([0-9]+x[0-9]+\+[0-9]+\+[0-9]+) ]]; then
            local name="${BASH_REMATCH[1]}"
            local geometry="${BASH_REMATCH[2]}"
            # Parse geometry: WIDTHxHEIGHT+X+Y
            if [[ $geometry =~ ^([0-9]+)x([0-9]+)\+([0-9]+)\+([0-9]+)$ ]]; then
                local w="${BASH_REMATCH[1]}"
                local h="${BASH_REMATCH[2]}"
                local x="${BASH_REMATCH[3]}"
                local y="${BASH_REMATCH[4]}"
                MONITORS+=("$name:$x:$y:$w:$h")
            fi
        fi
    done < <(xrandr --query 2>/dev/null)
    
    export MONITORS
    
    # If no monitors detected, create a fallback for the entire screen
    if [[ ${#MONITORS[@]} -eq 0 ]]; then
        MONITORS=("default:0:0:$SCREEN_W:$SCREEN_H")
    fi
}

# Get which monitor a window is primarily on
get_window_monitor() {
    local window_id="$1"
    local geom=$(get_window_geometry "$window_id")
    IFS=',' read -r wx wy ww wh <<< "$geom"
    
    local best_monitor=""
    local best_overlap=0
    
    for monitor in "${MONITORS[@]}"; do
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        
        # Calculate overlap area
        local overlap_x1=$((wx > mx ? wx : mx))
        local overlap_y1=$((wy > my ? wy : my))
        local overlap_x2=$(((wx + ww) < (mx + mw) ? (wx + ww) : (mx + mw)))
        local overlap_y2=$(((wy + wh) < (my + mh) ? (wy + wh) : (my + mh)))
        
        if [[ $overlap_x2 -gt $overlap_x1 && $overlap_y2 -gt $overlap_y1 ]]; then
            local overlap_area=$(((overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1)))
            if [[ $overlap_area -gt $best_overlap ]]; then
                best_overlap=$overlap_area
                best_monitor="$monitor"
            fi
        fi
    done
    
    # If no overlap found, use first monitor
    [[ -z "$best_monitor" ]] && best_monitor="${MONITORS[0]}"
    echo "$best_monitor"
}

# Get monitor-specific layout area
get_monitor_layout_area() {
    local monitor="$1"
    IFS=':' read -r name mx my mw mh <<< "$monitor"
    
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    local panel_autohide="${PANEL_AUTOHIDE:-false}"
    
    local usable_x=$((mx + gap))
    local usable_y=$((my + gap))  # Always start at top + gap
    local usable_w=$((mw - gap * 2))
    local usable_h
    
    # Handle panel height in usable_h calculation
    if [[ "$panel_autohide" != "true" ]]; then
        # Panel reserves space - subtract panel height from available height
        # Only apply panel height on primary monitor (usually the one containing 0,0)
        if [[ $mx -eq 0 && $my -eq 0 ]]; then
            # Panel at top reserves space, so start windows below it
            usable_y=$((my + panel_height + gap))
            usable_h=$((mh - panel_height - gap * 2))
        else
            # No panel on this monitor
            usable_h=$((mh - gap * 2))
        fi
    else
        # Panel auto-hides - use full monitor height (windows can overlap panel area)
        usable_h=$((mh - gap * 2))
    fi
    
    echo "$usable_x:$usable_y:$usable_w:$usable_h"
}

# Function to ensure minimum window size
ensure_minimum_size() {
    local w="$1" h="$2"
    w=$((w < MIN_WIDTH ? MIN_WIDTH : w))
    h=$((h < MIN_HEIGHT ? MIN_HEIGHT : h))
    echo "$w $h"
}

# Function to get all visible windows (not minimized or maximized)
get_visible_windows() {
    local current_desktop=$(xdotool get_desktop)
    wmctrl -l | while read -r line; do
        local id=$(echo "$line" | awk '{print $1}')
        local desktop=$(echo "$line" | awk '{print $2}')
        
        # Skip windows not on current desktop
        [[ "$desktop" != "$current_desktop" && "$desktop" != "-1" ]] && continue
        
        # Check if window is minimized or maximized
        local state=$(xprop -id "$id" _NET_WM_STATE 2>/dev/null | grep -E "HIDDEN|MAXIMIZED")
        [[ -n "$state" ]] && continue
        
        # Skip panels, docks, and desktop
        local type=$(xprop -id "$id" _NET_WM_WINDOW_TYPE 2>/dev/null)
        if echo "$type" | grep -qE "DOCK|DESKTOP|TOOLBAR|MENU|SPLASH|NOTIFICATION"; then
            continue
        fi
        
        echo "$id"
    done
}

# Auto-layout functions for different window counts
auto_layout_1_window() {
    local id="$1"
    get_screen_info
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    local usable_w=$((SCREEN_W - gap * 2))
    local usable_h=$((SCREEN_H - panel_height - gap * 2))
    
    # Maximize with gaps
    apply_geometry "$id" $gap $((panel_height + gap)) $usable_w $usable_h
}

auto_layout_2_windows() {
    local layout="$1"
    shift
    local ids=("$@")
    get_screen_info
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    local usable_w=$((SCREEN_W - gap * 3))
    local usable_h=$((SCREEN_H - panel_height - gap * 2))
    
    case "$layout" in
        equal)
            # 50/50 split
            local w=$((usable_w / 2))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w)) $((panel_height + gap)) $w $usable_h
            ;;
        primary-secondary)
            # 70/30 split
            local w1=$((usable_w * 70 / 100))
            local w2=$((usable_w - w1))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w1 $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w1)) $((panel_height + gap)) $w2 $usable_h
            ;;
        secondary-primary)
            # 30/70 split
            local w1=$((usable_w * 30 / 100))
            local w2=$((usable_w - w1))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w1 $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w1)) $((panel_height + gap)) $w2 $usable_h
            ;;
    esac
}

auto_layout_3_windows() {
    local layout="$1"
    shift
    local ids=("$@")
    get_screen_info
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    local usable_w=$((SCREEN_W - gap * 4))
    local usable_h=$((SCREEN_H - panel_height - gap * 2))
    
    case "$layout" in
        main-two-side)
            # One left half, two stacked on right
            local w1=$((usable_w / 2))
            local w2=$((usable_w - w1))
            local h2=$((usable_h / 2))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w1 $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w1)) $((panel_height + gap)) $w2 $((h2 - gap / 2))
            apply_geometry "${ids[2]}" $((gap * 2 + w1)) $((panel_height + gap * 2 + h2)) $w2 $((h2 - gap / 2))
            ;;
        three-columns)
            # Three equal columns
            local w=$((usable_w / 3))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w)) $((panel_height + gap)) $w $usable_h
            apply_geometry "${ids[2]}" $((gap * 3 + w * 2)) $((panel_height + gap)) $w $usable_h
            ;;
        center-sidebars)
            # 20/60/20 split
            local w1=$((usable_w * 20 / 100))
            local w2=$((usable_w * 60 / 100))
            local w3=$((usable_w - w1 - w2))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w1 $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w1)) $((panel_height + gap)) $w2 $usable_h
            apply_geometry "${ids[2]}" $((gap * 3 + w1 + w2)) $((panel_height + gap)) $w3 $usable_h
            ;;
    esac
}

auto_layout_4_windows() {
    local layout="$1"
    shift
    local ids=("$@")
    get_screen_info
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    
    case "$layout" in
        grid)
            # 2x2 grid
            local usable_w=$((SCREEN_W - gap * 3))
            local usable_h=$((SCREEN_H - panel_height - gap * 3))
            local w=$((usable_w / 2))
            local h=$((usable_h / 2))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w $h
            apply_geometry "${ids[1]}" $((gap * 2 + w)) $((panel_height + gap)) $w $h
            apply_geometry "${ids[2]}" $gap $((panel_height + gap * 2 + h)) $w $h
            apply_geometry "${ids[3]}" $((gap * 2 + w)) $((panel_height + gap * 2 + h)) $w $h
            ;;
        main-three-side)
            # One left half, three stacked on right
            local usable_w=$((SCREEN_W - gap * 3))
            local usable_h=$((SCREEN_H - panel_height - gap * 2))
            local w1=$((usable_w / 2))
            local w2=$((usable_w - w1))
            local h2=$((usable_h / 3))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w1 $usable_h
            apply_geometry "${ids[1]}" $((gap * 2 + w1)) $((panel_height + gap)) $w2 $((h2 - gap * 2 / 3))
            apply_geometry "${ids[2]}" $((gap * 2 + w1)) $((panel_height + gap + h2 + gap / 3)) $w2 $((h2 - gap * 2 / 3))
            apply_geometry "${ids[3]}" $((gap * 2 + w1)) $((panel_height + gap + h2 * 2 + gap * 2 / 3)) $w2 $((h2 - gap * 2 / 3))
            ;;
        three-top-bottom)
            # Three columns on top, one wide bottom (like 3-window center-sidebars + bottom bar)
            local usable_w=$((SCREEN_W - gap * 4))
            local usable_h=$((SCREEN_H - panel_height - gap * 3))
            local h1=$((usable_h * 60 / 100))
            local h2=$((usable_h - h1))
            local w1=$((usable_w * 20 / 100))
            local w2=$((usable_w * 60 / 100))
            local w3=$((usable_w - w1 - w2))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w1 $h1
            apply_geometry "${ids[1]}" $((gap * 2 + w1)) $((panel_height + gap)) $w2 $h1
            apply_geometry "${ids[2]}" $((gap * 3 + w1 + w2)) $((panel_height + gap)) $w3 $h1
            apply_geometry "${ids[3]}" $gap $((panel_height + gap * 2 + h1)) $((SCREEN_W - gap * 2)) $h2
            ;;
    esac
}

auto_layout_5_windows() {
    local layout="$1"
    shift
    local ids=("$@")
    get_screen_info
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    local usable_w=$((SCREEN_W - gap * 3))
    local usable_h=$((SCREEN_H - panel_height - gap * 3))
    
    case "$layout" in
        center-corners)
            # One center, four corners
            local corner_w=$((usable_w * 30 / 100))
            local corner_h=$((usable_h * 40 / 100))
            local center_w=$((usable_w - corner_w * 2 - gap * 2))
            local center_h=$((usable_h - corner_h * 2 - gap * 2))
            local center_x=$((gap + corner_w + gap))
            local center_y=$((panel_height + gap + corner_h + gap))
            
            # Center window
            apply_geometry "${ids[0]}" $center_x $center_y $center_w $center_h
            # Corners
            apply_geometry "${ids[1]}" $gap $((panel_height + gap)) $corner_w $corner_h
            apply_geometry "${ids[2]}" $((SCREEN_W - gap - corner_w)) $((panel_height + gap)) $corner_w $corner_h
            apply_geometry "${ids[3]}" $gap $((SCREEN_H - gap - corner_h)) $corner_w $corner_h
            apply_geometry "${ids[4]}" $((SCREEN_W - gap - corner_w)) $((SCREEN_H - gap - corner_h)) $corner_w $corner_h
            ;;
        two-three-columns)
            # 2 windows on left, 3 on right
            local w=$((usable_w / 2))
            local h_left=$((usable_h / 2))
            local h_right=$((usable_h / 3))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w $((h_left - gap / 2))
            apply_geometry "${ids[1]}" $gap $((panel_height + gap * 2 + h_left)) $w $((h_left - gap / 2))
            apply_geometry "${ids[2]}" $((gap * 2 + w)) $((panel_height + gap)) $w $((h_right - gap * 2 / 3))
            apply_geometry "${ids[3]}" $((gap * 2 + w)) $((panel_height + gap + h_right + gap / 3)) $w $((h_right - gap * 2 / 3))
            apply_geometry "${ids[4]}" $((gap * 2 + w)) $((panel_height + gap + h_right * 2 + gap * 2 / 3)) $w $((h_right - gap * 2 / 3))
            ;;
        grid-wide-bottom)
            # 2x2 grid on top, one wide on bottom
            local h1=$((usable_h * 60 / 100))
            local h2=$((usable_h - h1 - gap))
            local w=$((usable_w / 2))
            local h_grid=$((h1 / 2))
            apply_geometry "${ids[0]}" $gap $((panel_height + gap)) $w $((h_grid - gap / 2))
            apply_geometry "${ids[1]}" $((gap * 2 + w)) $((panel_height + gap)) $w $((h_grid - gap / 2))
            apply_geometry "${ids[2]}" $gap $((panel_height + gap + h_grid + gap / 2)) $w $((h_grid - gap / 2))
            apply_geometry "${ids[3]}" $((gap * 2 + w)) $((panel_height + gap + h_grid + gap / 2)) $w $((h_grid - gap / 2))
            apply_geometry "${ids[4]}" $gap $((panel_height + gap * 2 + h1)) $((SCREEN_W - gap * 2)) $h2
            ;;
    esac
}

# Main auto-layout function (monitor-aware)
auto_layout() {
    echo "Detecting visible windows..."
    local windows=($(get_visible_windows))
    local count=${#windows[@]}
    
    if [[ $count -eq 0 ]]; then
        echo "No visible windows found"
        return 1
    fi
    
    get_screen_info
    
    # Group windows by monitor
    declare -A monitor_windows
    for window_id in "${windows[@]}"; do
        local monitor=$(get_window_monitor "$window_id")
        IFS=':' read -r name mx my mw mh <<< "$monitor"
        local key="${mx},${my}"  # Use coordinates as unique key
        if [[ "${monitor_windows[$key]:-}" ]]; then
            monitor_windows[$key]="${monitor_windows[$key]} $window_id"
        else
            monitor_windows[$key]="$window_id"
        fi
    done
    
    echo "Found $count visible window(s) across ${#monitor_windows[@]} monitor(s)"
    
    # Apply layout to each monitor's windows
    for key in "${!monitor_windows[@]}"; do
        local window_list=(${monitor_windows[$key]})
        local window_count=${#window_list[@]}
        
        # Find the monitor info for this group
        local target_monitor=""
        for monitor in "${MONITORS[@]}"; do
            IFS=':' read -r name mx my mw mh <<< "$monitor"
            if [[ "$key" == "${mx},${my}" ]]; then
                target_monitor="$monitor"
                break
            fi
        done
        
        if [[ -n "$target_monitor" ]]; then
            IFS=':' read -r name mx my mw mh <<< "$target_monitor"
            echo "Monitor $name: Arranging $window_count window(s)"
            
            # Apply layout based on window count on this monitor
            source "$SETTINGS_FILE"
            case $window_count in
                1)
                    echo "  Applying layout: ${AUTO_LAYOUT_1:-maximize}"
                    auto_layout_monitor_1_window "$target_monitor" "${window_list[0]}"
                    ;;
                2)
                    local layout="${AUTO_LAYOUT_2:-equal}"
                    echo "  Applying 2-window layout: $layout"
                    auto_layout_monitor_2_windows "$target_monitor" "$layout" "${window_list[@]}"
                    ;;
                3)
                    local layout="${AUTO_LAYOUT_3:-main-two-side}"
                    echo "  Applying 3-window layout: $layout"
                    auto_layout_monitor_3_windows "$target_monitor" "$layout" "${window_list[@]}"
                    ;;
                4)
                    local layout="${AUTO_LAYOUT_4:-grid}"
                    echo "  Applying 4-window layout: $layout"
                    auto_layout_monitor_4_windows "$target_monitor" "$layout" "${window_list[@]}"
                    ;;
                5)
                    local layout="${AUTO_LAYOUT_5:-grid-wide-bottom}"
                    echo "  Applying 5-window layout: $layout"
                    auto_layout_monitor_5_windows "$target_monitor" "$layout" "${window_list[@]}"
                    ;;
                *)
                    echo "  Warning: $window_count windows on this monitor (max 5 supported)"
                    # Fall back to maximize first window
                    auto_layout_monitor_1_window "$target_monitor" "${window_list[0]}"
                    ;;
            esac
        fi
    done
    
    echo "Multi-monitor auto-layout applied successfully"
}

# Monitor-specific auto-layout functions
auto_layout_monitor_1_window() {
    local monitor="$1" id="$2"
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    # Maximize with gaps
    apply_geometry "$id" $usable_x $usable_y $usable_w $usable_h
}

auto_layout_monitor_2_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        equal)
            # 50/50 split with gap between
            local gap=$GAP
            local w=$(((usable_w - gap) / 2))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w + gap)) $usable_y $w $usable_h
            ;;
        primary-secondary)
            # 70/30 split with gap between
            local gap=$GAP
            local w1=$(((usable_w - gap) * 70 / 100))
            local w2=$((usable_w - w1 - gap))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w1 $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w1 + gap)) $usable_y $w2 $usable_h
            ;;
        secondary-primary)
            # 30/70 split with gap between
            local gap=$GAP
            local w1=$(((usable_w - gap) * 30 / 100))
            local w2=$((usable_w - w1 - gap))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w1 $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w1 + gap)) $usable_y $w2 $usable_h
            ;;
    esac
}

auto_layout_monitor_3_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        main-two-side)
            # One left half, two stacked on right with gaps
            local gap=$GAP
            local w1=$(((usable_w - gap) / 2))
            local w2=$((usable_w - w1 - gap))
            local h2=$(((usable_h - gap) / 2))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w1 $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w1 + gap)) $usable_y $w2 $h2
            apply_geometry "${ids[2]}" $((usable_x + w1 + gap)) $((usable_y + h2 + gap)) $w2 $h2
            ;;
        three-columns)
            # Three equal columns with gaps
            local gap=$GAP
            local w=$(((usable_w - gap * 2) / 3))  # 2 gaps between 3 columns
            apply_geometry "${ids[0]}" $usable_x $usable_y $w $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w + gap)) $usable_y $w $usable_h
            apply_geometry "${ids[2]}" $((usable_x + (w + gap) * 2)) $usable_y $w $usable_h
            ;;
        center-sidebars)
            # 20/60/20 split with gaps
            local gap=$GAP
            local total_gap=$((gap * 2))  # 2 gaps between 3 windows
            local w1=$(((usable_w - total_gap) * 20 / 100))
            local w2=$(((usable_w - total_gap) * 60 / 100))
            local w3=$((usable_w - w1 - w2 - total_gap))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w1 $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w1 + gap)) $usable_y $w2 $usable_h
            apply_geometry "${ids[2]}" $((usable_x + w1 + w2 + total_gap)) $usable_y $w3 $usable_h
            ;;
    esac
}

auto_layout_monitor_4_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        grid)
            # 2x2 grid with gaps between windows
            local gap=$GAP
            local w=$(((usable_w - gap) / 2))  # Account for gap between columns
            local h=$(((usable_h - gap) / 2))  # Account for gap between rows
            apply_geometry "${ids[0]}" $usable_x $usable_y $w $h
            apply_geometry "${ids[1]}" $((usable_x + w + gap)) $usable_y $w $h
            apply_geometry "${ids[2]}" $usable_x $((usable_y + h + gap)) $w $h
            apply_geometry "${ids[3]}" $((usable_x + w + gap)) $((usable_y + h + gap)) $w $h
            ;;
        main-three-side)
            # One left half, three stacked on right with gaps
            local gap=$GAP
            local w1=$(((usable_w - gap) / 2))
            local w2=$((usable_w - w1 - gap))
            local h2=$(((usable_h - gap * 2) / 3))  # 2 gaps between 3 stacked windows
            apply_geometry "${ids[0]}" $usable_x $usable_y $w1 $usable_h
            apply_geometry "${ids[1]}" $((usable_x + w1 + gap)) $usable_y $w2 $h2
            apply_geometry "${ids[2]}" $((usable_x + w1 + gap)) $((usable_y + h2 + gap)) $w2 $h2
            apply_geometry "${ids[3]}" $((usable_x + w1 + gap)) $((usable_y + (h2 + gap) * 2)) $w2 $h2
            ;;
        three-top-bottom)
            # Three columns on top, one wide bottom with gaps
            local gap=$GAP
            local h1=$(((usable_h - gap) * 60 / 100))
            local h2=$((usable_h - h1 - gap))
            local total_gap=$((gap * 2))  # 2 gaps between 3 top windows
            local w1=$(((usable_w - total_gap) * 20 / 100))
            local w2=$(((usable_w - total_gap) * 60 / 100))
            local w3=$((usable_w - w1 - w2 - total_gap))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w1 $h1
            apply_geometry "${ids[1]}" $((usable_x + w1 + gap)) $usable_y $w2 $h1
            apply_geometry "${ids[2]}" $((usable_x + w1 + w2 + total_gap)) $usable_y $w3 $h1
            apply_geometry "${ids[3]}" $usable_x $((usable_y + h1 + gap)) $usable_w $h2
            ;;
    esac
}

auto_layout_monitor_5_windows() {
    local monitor="$1" layout="$2"
    shift 2
    local ids=("$@")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    case "$layout" in
        center-corners)
            # One center, four corners with gaps
            local gap=$GAP
            local corner_w=$(((usable_w - gap * 2) * 30 / 100))
            local corner_h=$(((usable_h - gap * 2) * 40 / 100))
            local center_w=$((usable_w - corner_w * 2 - gap * 2))
            local center_h=$((usable_h - corner_h * 2 - gap * 2))
            local center_x=$((usable_x + corner_w + gap))
            local center_y=$((usable_y + corner_h + gap))
            
            # Center window
            apply_geometry "${ids[0]}" $center_x $center_y $center_w $center_h
            # Corners
            apply_geometry "${ids[1]}" $usable_x $usable_y $corner_w $corner_h
            apply_geometry "${ids[2]}" $((usable_x + usable_w - corner_w)) $usable_y $corner_w $corner_h
            apply_geometry "${ids[3]}" $usable_x $((usable_y + usable_h - corner_h)) $corner_w $corner_h
            apply_geometry "${ids[4]}" $((usable_x + usable_w - corner_w)) $((usable_y + usable_h - corner_h)) $corner_w $corner_h
            ;;
        two-three-columns)
            # 2 windows on left, 3 on right with gaps
            local gap=$GAP
            local w=$(((usable_w - gap) / 2))
            local h_left=$(((usable_h - gap) / 2))
            local h_right=$(((usable_h - gap * 2) / 3))
            apply_geometry "${ids[0]}" $usable_x $usable_y $w $h_left
            apply_geometry "${ids[1]}" $usable_x $((usable_y + h_left + gap)) $w $h_left
            apply_geometry "${ids[2]}" $((usable_x + w + gap)) $usable_y $w $h_right
            apply_geometry "${ids[3]}" $((usable_x + w + gap)) $((usable_y + h_right + gap)) $w $h_right
            apply_geometry "${ids[4]}" $((usable_x + w + gap)) $((usable_y + (h_right + gap) * 2)) $w $h_right
            ;;
        grid-wide-bottom)
            # 2x2 grid on top, one wide on bottom with gaps
            local gap=$GAP
            local h1=$(((usable_h - gap * 2) * 60 / 100))  # Account for gaps above and below grid
            local h2=$((usable_h - h1 - gap))
            local w=$(((usable_w - gap) / 2))
            local h_grid=$(((h1 - gap) / 2))  # Gap between grid rows
            apply_geometry "${ids[0]}" $usable_x $usable_y $w $h_grid
            apply_geometry "${ids[1]}" $((usable_x + w + gap)) $usable_y $w $h_grid
            apply_geometry "${ids[2]}" $usable_x $((usable_y + h_grid + gap)) $w $h_grid
            apply_geometry "${ids[3]}" $((usable_x + w + gap)) $((usable_y + h_grid + gap)) $w $h_grid
            apply_geometry "${ids[4]}" $usable_x $((usable_y + h1 + gap)) $usable_w $h2
            ;;
    esac
}

# Function to find adjacent windows (side-by-side or stacked)
find_adjacent_windows() {
    local target_id="$1"
    local target_geom=$(get_window_geometry "$target_id")
    IFS=',' read -r tx ty tw th <<< "$target_geom"
    
    local adjacent=()
    local windows=($(get_visible_windows))
    
    for id in "${windows[@]}"; do
        [[ "$id" == "$target_id" ]] && continue
        
        local geom=$(get_window_geometry "$id")
        IFS=',' read -r x y w h <<< "$geom"
        
        # Check if windows share an edge (horizontally or vertically adjacent)
        local gap_tolerance=20  # Allow for small gaps
        
        # Horizontal adjacency (side by side)
        if [[ $((ty - gap_tolerance)) -le $((y + h)) && $((ty + th + gap_tolerance)) -ge $y ]]; then
            # Left adjacent
            if [[ $((tx - gap_tolerance)) -le $((x + w)) && $((tx - gap_tolerance)) -ge $x ]]; then
                adjacent+=("$id:left")
            fi
            # Right adjacent  
            if [[ $((tx + tw + gap_tolerance)) -ge $x && $((tx + tw - gap_tolerance)) -le $((x + w)) ]]; then
                adjacent+=("$id:right")
            fi
        fi
        
        # Vertical adjacency (stacked)
        if [[ $((tx - gap_tolerance)) -le $((x + w)) && $((tx + tw + gap_tolerance)) -ge $x ]]; then
            # Top adjacent
            if [[ $((ty - gap_tolerance)) -le $((y + h)) && $((ty - gap_tolerance)) -ge $y ]]; then
                adjacent+=("$id:top")
            fi
            # Bottom adjacent
            if [[ $((ty + th + gap_tolerance)) -ge $y && $((ty + th - gap_tolerance)) -le $((y + h)) ]]; then
                adjacent+=("$id:bottom")
            fi
        fi
    done
    
    printf '%s\n' "${adjacent[@]}"
}

# Simultaneous resize function
simultaneous_resize() {
    local direction="$1"  # expand-right, shrink-right, expand-down, shrink-down
    local amount="${2:-50}"  # pixels to resize
    
    local target_id=$(pick_window)
    echo "Finding adjacent windows..."
    
    local adjacent=($(find_adjacent_windows "$target_id"))
    if [[ ${#adjacent[@]} -eq 0 ]]; then
        echo "No adjacent windows found for simultaneous resize"
        return 1
    fi
    
    echo "Found ${#adjacent[@]} adjacent window(s)"
    
    local target_geom=$(get_window_geometry "$target_id")
    IFS=',' read -r tx ty tw th <<< "$target_geom"
    
    case "$direction" in
        expand-right|shrink-right)
            local new_tw=$((tw + (direction == "expand-right" ? amount : -amount)))
            apply_geometry "$target_id" $tx $ty $new_tw $th
            
            # Adjust right-adjacent windows
            for adj in "${adjacent[@]}"; do
                local adj_id="${adj%:*}"
                local adj_dir="${adj#*:}"
                if [[ "$adj_dir" == "right" ]]; then
                    local adj_geom=$(get_window_geometry "$adj_id")
                    IFS=',' read -r ax ay aw ah <<< "$adj_geom"
                    local new_ax=$((ax + (direction == "expand-right" ? amount : -amount)))
                    local new_aw=$((aw + (direction == "expand-right" ? -amount : amount)))
                    apply_geometry "$adj_id" $new_ax $ay $new_aw $ah
                fi
            done
            ;;
        expand-down|shrink-down)
            local new_th=$((th + (direction == "expand-down" ? amount : -amount)))
            apply_geometry "$target_id" $tx $ty $tw $new_th
            
            # Adjust bottom-adjacent windows
            for adj in "${adjacent[@]}"; do
                local adj_id="${adj%:*}"
                local adj_dir="${adj#*:}"
                if [[ "$adj_dir" == "bottom" ]]; then
                    local adj_geom=$(get_window_geometry "$adj_id")
                    IFS=',' read -r ax ay aw ah <<< "$adj_geom"
                    local new_ay=$((ay + (direction == "expand-down" ? amount : -amount)))
                    local new_ah=$((ah + (direction == "expand-down" ? -amount : amount)))
                    apply_geometry "$adj_id" $new_ax $new_ay $aw $new_ah
                fi
            done
            ;;
    esac
    
    echo "Simultaneous resize completed"
}

# Master-stack layouts (xpytile-inspired)
master_stack_layout() {
    local orientation="$1"  # vertical or horizontal
    local windows=($(get_visible_windows))
    local count=${#windows[@]}
    
    if [[ $count -lt 2 ]]; then
        echo "Master-stack requires at least 2 windows"
        return 1
    fi
    
    get_screen_info
    local gap=$GAP
    local panel_height=$PANEL_HEIGHT
    local usable_w=$((SCREEN_W - gap * 3))
    local usable_h=$((SCREEN_H - panel_height - gap * 2))
    
    # Master window gets 60% of space, stack gets 40%
    local master_id="${windows[0]}"
    local stack_ids=("${windows[@]:1}")
    
    case "$orientation" in
        vertical)
            # Master on left, stack on right
            local master_w=$((usable_w * 60 / 100))
            local stack_w=$((usable_w - master_w))
            local stack_h=$((usable_h / ${#stack_ids[@]}))
            
            # Position master
            apply_geometry "$master_id" $gap $((panel_height + gap)) $master_w $usable_h
            
            # Position stack
            local stack_y=$((panel_height + gap))
            for stack_id in "${stack_ids[@]}"; do
                apply_geometry "$stack_id" $((gap * 2 + master_w)) $stack_y $stack_w $((stack_h - gap))
                stack_y=$((stack_y + stack_h))
            done
            ;;
        horizontal)
            # Master on top, stack on bottom
            local master_h=$((usable_h * 60 / 100))
            local stack_h=$((usable_h - master_h))
            local stack_w=$((usable_w / ${#stack_ids[@]}))
            
            # Position master
            apply_geometry "$master_id" $gap $((panel_height + gap)) $usable_w $master_h
            
            # Position stack
            local stack_x=$gap
            for stack_id in "${stack_ids[@]}"; do
                apply_geometry "$stack_id" $stack_x $((panel_height + gap * 2 + master_h)) $((stack_w - gap)) $stack_h
                stack_x=$((stack_x + stack_w))
            done
            ;;
    esac
    
    echo "Master-stack layout ($orientation) applied to $count windows"
}

# Focus navigation
focus_window() {
    local direction="$1"  # next, prev, up, down, left, right
    local current_id=$(xdotool getactivewindow 2>/dev/null || echo "")
    
    if [[ -z "$current_id" ]]; then
        echo "No active window found"
        return 1
    fi
    
    local windows=($(get_visible_windows))
    local target_id=""
    
    case "$direction" in
        next)
            # Find next window in list
            for i in "${!windows[@]}"; do
                if [[ "${windows[i]}" == "$current_id" ]]; then
                    target_id="${windows[$(((i + 1) % ${#windows[@]}))]}"
                    break
                fi
            done
            ;;
        prev)
            # Find previous window in list
            for i in "${!windows[@]}"; do
                if [[ "${windows[i]}" == "$current_id" ]]; then
                    target_id="${windows[$(((i - 1 + ${#windows[@]}) % ${#windows[@]}))]}"
                    break
                fi
            done
            ;;
        up|down|left|right)
            # Find geometrically adjacent window
            local current_geom=$(get_window_geometry "$current_id")
            IFS=',' read -r cx cy cw ch <<< "$current_geom"
            local best_distance=999999
            
            for id in "${windows[@]}"; do
                [[ "$id" == "$current_id" ]] && continue
                
                local geom=$(get_window_geometry "$id")
                IFS=',' read -r x y w h <<< "$geom"
                
                case "$direction" in
                    up)    [[ $((y + h)) -le $cy ]] && distance=$((cy - (y + h))) ;;
                    down)  [[ $y -ge $((cy + ch)) ]] && distance=$((y - (cy + ch))) ;;
                    left)  [[ $((x + w)) -le $cx ]] && distance=$((cx - (x + w))) ;;
                    right) [[ $x -ge $((cx + cw)) ]] && distance=$((x - (cx + cw))) ;;
                esac
                
                if [[ ${distance:-999999} -lt $best_distance ]]; then
                    best_distance=$distance
                    target_id="$id"
                fi
            done
            ;;
    esac
    
    if [[ -n "$target_id" ]]; then
        xdotool windowactivate "$target_id"
        echo "Focused window: $target_id"
    else
        echo "No window found in direction: $direction"
    fi
}

# Apply preset layouts with configurable gaps (monitor-aware)
apply_preset() {
    local preset="$1" id="$2"
    get_screen_info
    
    # Determine which monitor the window is primarily on
    local monitor=$(get_window_monitor "$id")
    local layout_area=$(get_monitor_layout_area "$monitor")
    IFS=':' read -r usable_x usable_y usable_w usable_h <<< "$layout_area"
    
    local half_w=$((usable_w / 2))
    local half_h=$((usable_h / 2))
    
    case "$preset" in
        ul) # Upper left
            read -r w h <<< "$(ensure_minimum_size $half_w $half_h)"
            apply_geometry "$id" $usable_x $usable_y $w $h
            ;;
        ur) # Upper right
            read -r w h <<< "$(ensure_minimum_size $half_w $half_h)"
            apply_geometry "$id" $((usable_x + half_w)) $usable_y $w $h
            ;;
        ll) # Lower left
            read -r w h <<< "$(ensure_minimum_size $half_w $half_h)"
            apply_geometry "$id" $usable_x $((usable_y + half_h)) $w $h
            ;;
        lr) # Lower right
            read -r w h <<< "$(ensure_minimum_size $half_w $half_h)"
            apply_geometry "$id" $((usable_x + half_w)) $((usable_y + half_h)) $w $h
            ;;
        c) # Center
            local center_w=$((usable_w * 2 / 3))
            local center_h=$((usable_h * 2 / 3))
            read -r center_w center_h <<< "$(ensure_minimum_size $center_w $center_h)"
            local center_x=$((usable_x + (usable_w - center_w) / 2))
            local center_y=$((usable_y + (usable_h - center_h) / 2))
            apply_geometry "$id" $center_x $center_y $center_w $center_h
            ;;
        left) # Left half
            read -r w h <<< "$(ensure_minimum_size $half_w $usable_h)"
            apply_geometry "$id" $usable_x $usable_y $w $h
            ;;
        right) # Right half
            read -r w h <<< "$(ensure_minimum_size $half_w $usable_h)"
            apply_geometry "$id" $((usable_x + half_w)) $usable_y $w $h
            ;;
        top) # Top half
            read -r w h <<< "$(ensure_minimum_size $usable_w $half_h)"
            apply_geometry "$id" $usable_x $usable_y $w $h
            ;;
        bottom) # Bottom half
            read -r w h <<< "$(ensure_minimum_size $usable_w $half_h)"
            apply_geometry "$id" $usable_x $((usable_y + half_h)) $w $h
            ;;
        maximize) # Maximize (with gaps)
            read -r w h <<< "$(ensure_minimum_size $usable_w $usable_h)"
            apply_geometry "$id" $usable_x $usable_y $w $h
            ;;
        *)
            # Check if it's a saved preset
            load_position "$preset" "$id"
            ;;
    esac
}

# Interactive mode menu
interactive_mode() {
    local id=$(pick_window)
    
    echo ""
    echo "Window Positioning - Interactive Mode"
    echo "====================================="
    echo "Current settings: Gap=${GAP}px, Panel=${PANEL_HEIGHT}px"
    echo ""
    echo "Quick presets:"
    echo "  1) Upper left (ul)      6) Left half"
    echo "  2) Upper right (ur)     7) Right half"
    echo "  3) Lower left (ll)      8) Top half"
    echo "  4) Lower right (lr)     9) Bottom half"
    echo "  5) Center (c)          10) Maximize"
    echo ""
    echo "Other options:"
    echo "  s) Save current position    g) Set gap size"
    echo "  l) Load saved position      p) Set panel height"
    echo "  c) Custom coordinates       r) Reload settings"
    echo "  w) Move to workspace        q) Quit"
    echo ""
    
    read -p "Choose option: " choice
    
    case "$choice" in
        1|ul) apply_preset "ul" "$id" ;;
        2|ur) apply_preset "ur" "$id" ;;
        3|ll) apply_preset "ll" "$id" ;;
        4|lr) apply_preset "lr" "$id" ;;
        5|c) apply_preset "c" "$id" ;;
        6) apply_preset "left" "$id" ;;
        7) apply_preset "right" "$id" ;;
        8) apply_preset "top" "$id" ;;
        9) apply_preset "bottom" "$id" ;;
        10) apply_preset "maximize" "$id" ;;
        s)
            read -p "Enter name for this position: " name
            save_position "$name" "$id"
            ;;
        l)
            echo "Available presets:"
            grep -v '^#' "$PRESETS_FILE" | cut -d= -f1 | sed 's/^/  - /'
            read -p "Enter preset name: " name
            load_position "$name" "$id"
            ;;
        c)
            read -p "Enter X Y Width Height (space-separated): " x y w h
            apply_geometry "$id" "$x" "$y" "$w" "$h"
            ;;
        w)
            read -p "Enter workspace number (1-based): " ws
            move_to_workspace "$id" $((ws - 1))
            ;;
        g)
            read -p "Enter new gap size (current: ${GAP}px): " new_gap
            if [[ "$new_gap" =~ ^[0-9]+$ ]]; then
                sed -i "s/^GAP=.*/GAP=${new_gap}/" "$SETTINGS_FILE"
                GAP=$new_gap
                echo "Gap size set to ${new_gap}px"
            else
                echo "Invalid gap size. Must be a number."
            fi
            ;;
        p)
            read -p "Enter new panel height (current: ${PANEL_HEIGHT}px): " new_panel
            if [[ "$new_panel" =~ ^[0-9]+$ ]]; then
                sed -i "s/^PANEL_HEIGHT=.*/PANEL_HEIGHT=${new_panel}/" "$SETTINGS_FILE"
                PANEL_HEIGHT=$new_panel
                echo "Panel height set to ${new_panel}px"
            else
                echo "Invalid panel height. Must be a number."
            fi
            ;;
        r)
            source "$SETTINGS_FILE"
            echo "Settings reloaded: Gap=${GAP}px, Panel=${PANEL_HEIGHT}px"
            ;;
        q)
            echo "Exiting..."
            exit 0
            ;;
        *)
            echo "Invalid option"
            exit 1
            ;;
    esac
}

# Window swap functions
drag_swap_windows() {
    echo "Click on the first window to select it for swapping..."
    local window1_id
    window1_id=$(pick_window)
    
    if [[ -z "$window1_id" ]]; then
        echo "No window selected. Aborting swap."
        return 1
    fi
    
    # Get first window's geometry and info
    local window1_geom
    window1_geom=$(xdotool getwindowgeometry --shell "$window1_id" 2>/dev/null)
    local window1_title
    window1_title=$(xdotool getwindowname "$window1_id" 2>/dev/null)
    
    if [[ -z "$window1_geom" ]]; then
        echo "Error: Could not get geometry for selected window"
        return 1
    fi
    
    echo "Selected: $window1_title"
    echo "Now click on the second window to swap with..."
    
    local window2_id
    window2_id=$(pick_window)
    
    if [[ -z "$window2_id" ]]; then
        echo "No second window selected. Aborting swap."
        return 1
    fi
    
    if [[ "$window1_id" == "$window2_id" ]]; then
        echo "Cannot swap a window with itself"
        return 1
    fi
    
    # Get second window's geometry and info
    local window2_geom
    window2_geom=$(xdotool getwindowgeometry --shell "$window2_id" 2>/dev/null)
    local window2_title
    window2_title=$(xdotool getwindowname "$window2_id" 2>/dev/null)
    
    if [[ -z "$window2_geom" ]]; then
        echo "Error: Could not get geometry for second window"
        return 1
    fi
    
    echo "Swapping positions between:"
    echo "  Window 1: $window1_title"
    echo "  Window 2: $window2_title"
    
    # Perform the swap
    swap_window_positions "$window1_id" "$window2_id"
}

interactive_swap_windows() {
    echo "Interactive swap mode: Click on two windows to swap their positions"
    echo ""
    
    echo "Click on the first window..."
    local window1_id
    window1_id=$(pick_window)
    
    if [[ -z "$window1_id" ]]; then
        echo "No window selected. Aborting swap."
        return 1
    fi
    
    local window1_title
    window1_title=$(xdotool getwindowname "$window1_id" 2>/dev/null)
    echo "✓ Selected first window: $window1_title"
    echo ""
    
    echo "Click on the second window..."
    local window2_id
    window2_id=$(pick_window)
    
    if [[ -z "$window2_id" ]]; then
        echo "No second window selected. Aborting swap."
        return 1
    fi
    
    if [[ "$window1_id" == "$window2_id" ]]; then
        echo "Cannot swap a window with itself"
        return 1
    fi
    
    local window2_title
    window2_title=$(xdotool getwindowname "$window2_id" 2>/dev/null)
    echo "✓ Selected second window: $window2_title"
    echo ""
    
    echo "Swapping positions..."
    swap_window_positions "$window1_id" "$window2_id"
}

swap_window_positions() {
    local window1_id="$1"
    local window2_id="$2"
    
    # Get geometries
    local window1_geom window2_geom
    window1_geom=$(xdotool getwindowgeometry --shell "$window1_id" 2>/dev/null)
    window2_geom=$(xdotool getwindowgeometry --shell "$window2_id" 2>/dev/null)
    
    if [[ -z "$window1_geom" || -z "$window2_geom" ]]; then
        echo "Error: Could not get window geometries for swap"
        return 1
    fi
    
    # Parse window 1 geometry
    eval "$window1_geom"
    local w1_x=$X w1_y=$Y w1_width=$WIDTH w1_height=$HEIGHT
    
    # Parse window 2 geometry  
    eval "$window2_geom"
    local w2_x=$X w2_y=$Y w2_width=$WIDTH w2_height=$HEIGHT
    
    # Perform the swap with a small delay to avoid conflicts
    echo "  Moving windows..."
    
    # Move window 1 to window 2's position
    xdotool windowmove "$window1_id" "$w2_x" "$w2_y"
    xdotool windowsize "$window1_id" "$w2_width" "$w2_height"
    
    # Small delay to ensure first move completes
    sleep 0.1
    
    # Move window 2 to window 1's position
    xdotool windowmove "$window2_id" "$w1_x" "$w1_y" 
    xdotool windowsize "$window2_id" "$w1_width" "$w1_height"
    
    echo "✓ Windows swapped successfully"
    
    # Get window titles for confirmation
    local title1 title2
    title1=$(xdotool getwindowname "$window1_id" 2>/dev/null || echo "Window $window1_id")
    title2=$(xdotool getwindowname "$window2_id" 2>/dev/null || echo "Window $window2_id") 
    
    echo "  $title1 → Position ${w2_x}×${w2_y} (${w2_width}×${w2_height})"
    echo "  $title2 → Position ${w1_x}×${w1_y} (${w1_width}×${w1_height})"
}

# Workspace profile functions
save_workspace_profile() {
    local profile_name="$1"
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    local profile_file="$profiles_dir/$profile_name.profile"
    
    # Create profiles directory if it doesn't exist
    mkdir -p "$profiles_dir"
    
    # Get current workspace
    local current_ws
    current_ws=$(xdotool get_desktop)
    
    echo "Saving workspace profile: $profile_name"
    echo "Current workspace: $current_ws"
    
    # Clear existing profile
    > "$profile_file"
    
    # Save workspace number
    echo "WORKSPACE=$current_ws" >> "$profile_file"
    echo "" >> "$profile_file"
    
    # Get all visible windows on current workspace
    local windows
    windows=$(wmctrl -l | awk -v ws="$current_ws" '$2 == ws {print $1}' | grep -v '^$')
    
    if [[ -z "$windows" ]]; then
        echo "No windows found on current workspace"
        rm -f "$profile_file"
        return 1
    fi
    
    local window_count=0
    echo "# Window layout for workspace $current_ws" >> "$profile_file"
    
    while read -r window_id; do
        if [[ -n "$window_id" ]]; then
            # Get window geometry and title
            local geom
            geom=$(xdotool getwindowgeometry --shell "$window_id" 2>/dev/null)
            
            if [[ -n "$geom" ]]; then
                eval "$geom"
                local title
                title=$(xdotool getwindowname "$window_id" 2>/dev/null | sed 's/["\]/\\&/g')
                
                echo "# Window: $title" >> "$profile_file"
                echo "WINDOW_${window_count}_ID=$window_id" >> "$profile_file"
                echo "WINDOW_${window_count}_X=$X" >> "$profile_file"
                echo "WINDOW_${window_count}_Y=$Y" >> "$profile_file"
                echo "WINDOW_${window_count}_WIDTH=$WIDTH" >> "$profile_file"
                echo "WINDOW_${window_count}_HEIGHT=$HEIGHT" >> "$profile_file"
                echo "WINDOW_${window_count}_TITLE=\"$title\"" >> "$profile_file"
                echo "" >> "$profile_file"
                
                ((window_count++))
            fi
        fi
    done <<< "$windows"
    
    echo "WINDOW_COUNT=$window_count" >> "$profile_file"
    
    echo "✓ Saved $window_count windows to profile: $profile_name"
    echo "Profile saved to: $profile_file"
}

load_workspace_profile() {
    local profile_name="$1"
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    local profile_file="$profiles_dir/$profile_name.profile"
    
    if [[ ! -f "$profile_file" ]]; then
        echo "Error: Profile '$profile_name' not found"
        echo "Available profiles:"
        list_workspace_profiles
        return 1
    fi
    
    echo "Loading workspace profile: $profile_name"
    
    # Source the profile
    source "$profile_file"
    
    local loaded_count=0
    local applied_count=0
    
    for ((i=0; i<WINDOW_COUNT; i++)); do
        local id_var="WINDOW_${i}_ID"
        local x_var="WINDOW_${i}_X"
        local y_var="WINDOW_${i}_Y"
        local width_var="WINDOW_${i}_WIDTH"
        local height_var="WINDOW_${i}_HEIGHT"
        local title_var="WINDOW_${i}_TITLE"
        
        local window_id="${!id_var:-}"
        local x="${!x_var:-}"
        local y="${!y_var:-}"
        local width="${!width_var:-}"
        local height="${!height_var:-}"
        local title="${!title_var:-}"
        
        if [[ -n "$window_id" && -n "$x" && -n "$y" && -n "$width" && -n "$height" ]]; then
            ((loaded_count++))
            
            # Check if window still exists
            if xdotool windowmap "$window_id" 2>/dev/null; then
                # Position the window
                xdotool windowmove "$window_id" "$x" "$y"
                xdotool windowsize "$window_id" "$width" "$height"
                ((applied_count++))
                echo "✓ Positioned: $title"
            else
                echo "⚠ Window no longer exists: $title"
            fi
        fi
    done
    
    echo ""
    echo "Profile loaded: $profile_name"
    echo "Windows loaded: $loaded_count"
    echo "Windows positioned: $applied_count"
}

list_workspace_profiles() {
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    
    if [[ ! -d "$profiles_dir" ]]; then
        echo "No workspace profiles found"
        echo "Create profiles with: place-window workspace save <name>"
        return
    fi
    
    local profiles
    profiles=$(find "$profiles_dir" -name "*.profile" -type f 2>/dev/null | sort)
    
    if [[ -z "$profiles" ]]; then
        echo "No workspace profiles found"
        echo "Create profiles with: place-window workspace save <name>"
        return
    fi
    
    echo "Available workspace profiles:"
    
    while read -r profile_file; do
        if [[ -n "$profile_file" ]]; then
            local profile_name
            profile_name=$(basename "$profile_file" .profile)
            
            # Get profile info
            local workspace_num window_count
            workspace_num=$(grep "^WORKSPACE=" "$profile_file" | cut -d= -f2)
            window_count=$(grep "^WINDOW_COUNT=" "$profile_file" | cut -d= -f2)
            
            echo "  $profile_name (workspace $workspace_num, $window_count windows)"
        fi
    done <<< "$profiles"
}

delete_workspace_profile() {
    local profile_name="$1"
    local profiles_dir="$CONFIG_DIR/workspace-profiles"
    local profile_file="$profiles_dir/$profile_name.profile"
    
    if [[ ! -f "$profile_file" ]]; then
        echo "Error: Profile '$profile_name' not found"
        list_workspace_profiles
        return 1
    fi
    
    echo "Deleting workspace profile: $profile_name"
    rm -f "$profile_file"
    echo "✓ Profile deleted"
}

# Watch daemon functions
watch_daemon() {
    # Start the daemon in the background
    exec "$0" watch daemon &
    local daemon_pid=$!
    echo "Watch daemon started (PID: $daemon_pid)"
    
    # Wait for the daemon process
    wait $daemon_pid
}

watch_daemon_internal() {
    # Internal daemon function - monitors for new windows
    local last_window_list=""
    local check_interval=2
    
    # Trap signals for clean exit
    trap 'echo "Watch daemon stopped"; exit 0' SIGINT SIGTERM
    
    echo "$(date): Watch daemon started"
    
    while true; do
        # Get current visible windows
        local current_windows
        current_windows=$(wmctrl -l | grep -v '^[^ ]* \-1 ' | grep -v 'Desktop$' | wc -l)
        
        # Get detailed window list for comparison
        local current_window_list
        current_window_list=$(wmctrl -lG | grep -v '^[^ ]* \-1 ' | grep -v 'Desktop$' | sort)
        
        # Check if window list has changed
        if [[ "$current_window_list" != "$last_window_list" ]]; then
            if [[ -n "$last_window_list" ]]; then
                # Windows changed - check if we should apply auto-layout
                local new_window_count
                new_window_count=$(echo "$current_window_list" | wc -l)
                
                if [[ $new_window_count -gt 0 && $new_window_count -le 5 ]]; then
                    echo "$(date): Window change detected ($new_window_count windows) - applying auto-layout"
                    
                    # Apply auto-layout with a small delay to ensure window is fully created
                    sleep 0.5
                    "$0" auto > /dev/null 2>&1
                fi
            fi
            last_window_list="$current_window_list"
        fi
        
        sleep $check_interval
    done
}

# Main logic
case "${1:-}" in
    "")
        # No arguments - interactive mode
        interactive_mode
        ;;
    ul|ur|ll|lr|c|left|right|top|bottom|maximize)
        # Preset layout
        id=$(pick_window)
        apply_preset "$1" "$id"
        ;;
    ws)
        # Move to workspace
        if [[ -z "${2:-}" ]]; then
            echo "Error: Workspace number required"
            exit 1
        fi
        id=$(pick_window)
        move_to_workspace "$id" "$2"
        ;;
    save)
        # Save current position
        if [[ -z "${2:-}" ]]; then
            echo "Error: Position name required"
            exit 1
        fi
        id=$(pick_window)
        save_position "$2" "$id"
        ;;
    load)
        # Load saved position
        if [[ -z "${2:-}" ]]; then
            echo "Error: Position name required"
            exit 1
        fi
        id=$(pick_window)
        load_position "$2" "$id"
        ;;
    list)
        # List saved presets
        echo "Available presets:"
        grep -v '^#' "$PRESETS_FILE" | cut -d= -f1 | sed 's/^/  - /'
        ;;
    monitors)
        # Show monitor information
        get_screen_info
        echo "Screen Resolution: ${SCREEN_W}x${SCREEN_H}"
        echo "Detected Monitors:"
        for i in "${!MONITORS[@]}"; do
            IFS=':' read -r name mx my mw mh <<< "${MONITORS[i]}"
            echo "  Monitor $((i+1)): $name (${mw}x${mh}+${mx}+${my})"
            
            local layout_area=$(get_monitor_layout_area "${MONITORS[i]}")
            IFS=':' read -r ux uy uw uh <<< "$layout_area"
            echo "    Usable area: ${uw}x${uh}+${ux}+${uy} (with gaps)"
        done
        
        if [[ ${#MONITORS[@]} -gt 1 ]]; then
            echo ""
            echo "Multi-monitor features:"
            echo "- Windows positioned on their current monitor"
            echo "- Panel height applied only to primary monitor"
            echo "- Auto-layout groups windows per monitor"
        fi
        ;;
    auto)
        # Auto-layout all visible windows
        auto_layout
        ;;
    resize)
        # Simultaneous resize with adjacent windows
        case "${2:-}" in
            expand-right|shrink-right|expand-down|shrink-down)
                simultaneous_resize "$2" "${3:-50}"
                ;;
            *)
                echo "Resize commands:"
                echo "  place-window resize expand-right [pixels]   Expand right, shrink adjacent"
                echo "  place-window resize shrink-right [pixels]   Shrink right, expand adjacent"
                echo "  place-window resize expand-down [pixels]    Expand down, shrink adjacent"
                echo "  place-window resize shrink-down [pixels]    Shrink down, expand adjacent"
                echo ""
                echo "Default resize amount: 50 pixels"
                ;;
        esac
        ;;
    master)
        # Master-stack layouts
        case "${2:-}" in
            vertical|horizontal)
                master_stack_layout "$2"
                ;;
            *)
                echo "Master-stack layouts:"
                echo "  place-window master vertical     Master left, stack right"
                echo "  place-window master horizontal   Master top, stack bottom"
                echo ""
                echo "Master window gets 60% of space, others stack in remaining 40%"
                ;;
        esac
        ;;
    focus)
        # Focus navigation
        case "${2:-}" in
            next|prev|up|down|left|right)
                focus_window "$2"
                ;;
            *)
                echo "Focus navigation:"
                echo "  place-window focus next     Focus next window"
                echo "  place-window focus prev     Focus previous window"
                echo "  place-window focus up       Focus window above"
                echo "  place-window focus down     Focus window below"
                echo "  place-window focus left     Focus window to the left"
                echo "  place-window focus right    Focus window to the right"
                ;;
        esac
        ;;
    auto-config)
        # Configure auto-layout preferences
        case "${2:-}" in
            1|2|3|4|5)
                local window_count="$2"
                local layout="${3:-}"
                case $window_count in
                    1)
                        if [[ -z "$layout" ]]; then
                            echo "Current 1-window layout: ${AUTO_LAYOUT_1:-maximize}"
                            echo "Available: maximize"
                        else
                            sed -i "s/^AUTO_LAYOUT_1=.*/AUTO_LAYOUT_1=\"$layout\"/" "$SETTINGS_FILE"
                            echo "1-window layout set to: $layout"
                        fi
                        ;;
                    2)
                        if [[ -z "$layout" ]]; then
                            echo "Current 2-window layout: ${AUTO_LAYOUT_2:-equal}"
                            echo "Available: equal, primary-secondary, secondary-primary"
                        else
                            sed -i "s/^AUTO_LAYOUT_2=.*/AUTO_LAYOUT_2=\"$layout\"/" "$SETTINGS_FILE"
                            echo "2-window layout set to: $layout"
                        fi
                        ;;
                    3)
                        if [[ -z "$layout" ]]; then
                            echo "Current 3-window layout: ${AUTO_LAYOUT_3:-main-two-side}"
                            echo "Available: main-two-side, three-columns, center-sidebars"
                        else
                            sed -i "s/^AUTO_LAYOUT_3=.*/AUTO_LAYOUT_3=\"$layout\"/" "$SETTINGS_FILE"
                            echo "3-window layout set to: $layout"
                        fi
                        ;;
                    4)
                        if [[ -z "$layout" ]]; then
                            echo "Current 4-window layout: ${AUTO_LAYOUT_4:-grid}"
                            echo "Available: grid, main-three-side, three-top-bottom"
                        else
                            sed -i "s/^AUTO_LAYOUT_4=.*/AUTO_LAYOUT_4=\"$layout\"/" "$SETTINGS_FILE"
                            echo "4-window layout set to: $layout"
                        fi
                        ;;
                    5)
                        if [[ -z "$layout" ]]; then
                            echo "Current 5-window layout: ${AUTO_LAYOUT_5:-grid-wide-bottom}"
                            echo "Available: center-corners, two-three-columns, grid-wide-bottom"
                        else
                            sed -i "s/^AUTO_LAYOUT_5=.*/AUTO_LAYOUT_5=\"$layout\"/" "$SETTINGS_FILE"
                            echo "5-window layout set to: $layout"
                        fi
                        ;;
                esac
                ;;
            show)
                echo "Auto-layout preferences:"
                echo "  1 window:  ${AUTO_LAYOUT_1:-maximize}"
                echo "  2 windows: ${AUTO_LAYOUT_2:-equal}"
                echo "  3 windows: ${AUTO_LAYOUT_3:-main-two-side}"
                echo "  4 windows: ${AUTO_LAYOUT_4:-grid}"
                echo "  5 windows: ${AUTO_LAYOUT_5:-grid-wide-bottom}"
                ;;
            *)
                echo "Auto-layout configuration:"
                echo "  place-window auto-config show              Show current preferences"
                echo "  place-window auto-config 1 [layout]        Set/show 1-window layout"
                echo "  place-window auto-config 2 [layout]        Set/show 2-window layout"
                echo "  place-window auto-config 3 [layout]        Set/show 3-window layout"
                echo "  place-window auto-config 4 [layout]        Set/show 4-window layout"
                echo "  place-window auto-config 5 [layout]        Set/show 5-window layout"
                echo ""
                echo "Available layouts:"
                echo "  1 window:  maximize"
                echo "  2 windows: equal, primary-secondary, secondary-primary"
                echo "  3 windows: main-two-side, three-columns, center-sidebars"
                echo "  4 windows: grid, main-three-side, three-top-bottom"
                echo "  5 windows: center-corners, two-three-columns, grid-wide-bottom"
                ;;
        esac
        ;;
    watch)
        # Watch mode for automatic window tiling
        case "${2:-}" in
            start)
                if pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    echo "Watch mode already running (PID: $(pgrep -f "place-window.*watch.*daemon"))"
                    exit 1
                fi
                echo "Starting watch mode daemon..."
                echo "Monitoring for new windows and automatically applying tiling layouts"
                echo "Press Ctrl+C to stop"
                echo ""
                
                # Start the watch daemon
                watch_daemon
                ;;
            stop)
                if ! pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    echo "Watch mode is not running"
                    exit 1
                fi
                
                echo "Stopping watch mode daemon..."
                pkill -f "place-window.*watch.*daemon"
                echo "Watch mode stopped"
                ;;
            status)
                if pgrep -f "place-window.*watch.*daemon" > /dev/null; then
                    echo "Watch mode is running (PID: $(pgrep -f "place-window.*watch.*daemon"))"
                else
                    echo "Watch mode is not running"
                fi
                ;;
            daemon)
                # Internal daemon mode - do not call directly
                watch_daemon_internal
                ;;
            *)
                echo "Watch mode commands:"
                echo "  place-window watch start    Start automatic tiling daemon"
                echo "  place-window watch stop     Stop the daemon"
                echo "  place-window watch status   Check daemon status"
                echo ""
                echo "Watch mode automatically applies auto-layout when new windows appear"
                echo "It monitors window creation events and maintains optimal layouts"
                ;;
        esac
        ;;
    swap)
        # Window swapping functionality
        case "${2:-}" in
            drag)
                echo "Drag-to-swap mode: Click and drag a window to swap with another"
                echo "Step 1: Click on the first window to start drag mode"
                drag_swap_windows
                ;;
            interactive)
                echo "Interactive swap: Click two windows to swap their positions"
                interactive_swap_windows
                ;;
            *)
                echo "Window swap commands:"
                echo "  place-window swap drag          Drag-to-swap mode (click and drag)"
                echo "  place-window swap interactive   Click two windows to swap positions"
                echo ""
                echo "Swap functionality allows you to exchange the positions and sizes"
                echo "of two windows to reorganize your tiled layout"
                ;;
        esac
        ;;
    workspace)
        # Workspace-specific configuration commands
        case "${2:-}" in
            save)
                if [[ -z "${3:-}" ]]; then
                    echo "Error: Profile name required"
                    echo "Usage: place-window workspace save <profile-name>"
                    exit 1
                fi
                save_workspace_profile "$3"
                ;;
            load)
                if [[ -z "${3:-}" ]]; then
                    echo "Error: Profile name required"
                    echo "Usage: place-window workspace load <profile-name>"
                    exit 1
                fi
                load_workspace_profile "$3"
                ;;
            list)
                list_workspace_profiles
                ;;
            delete)
                if [[ -z "${3:-}" ]]; then
                    echo "Error: Profile name required"
                    echo "Usage: place-window workspace delete <profile-name>"
                    exit 1
                fi
                delete_workspace_profile "$3"
                ;;
            *)
                echo "Workspace profile commands:"
                echo "  place-window workspace save <name>     Save current workspace layout"
                echo "  place-window workspace load <name>     Load saved workspace layout"
                echo "  place-window workspace list            List all saved profiles"
                echo "  place-window workspace delete <name>   Delete a profile"
                echo ""
                echo "Workspace profiles save the position and layout of all windows"
                echo "on the current workspace, allowing you to restore entire layouts"
                ;;
        esac
        ;;
    config)
        # Configuration commands
        case "${2:-}" in
            gap)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" =~ ^[0-9]+$ ]]; then
                        sed -i "s/^GAP=.*/GAP=$3/" "$SETTINGS_FILE"
                        echo "Gap size set to ${3}px"
                    else
                        echo "Error: Gap size must be a number"
                        exit 1
                    fi
                else
                    echo "Current gap size: ${GAP}px"
                fi
                ;;
            panel)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" =~ ^[0-9]+$ ]]; then
                        sed -i "s/^PANEL_HEIGHT=.*/PANEL_HEIGHT=$3/" "$SETTINGS_FILE"
                        echo "Panel height set to ${3}px"
                    else
                        echo "Error: Panel height must be a number"
                        exit 1
                    fi
                else
                    echo "Current panel height: ${PANEL_HEIGHT}px"
                fi
                ;;
            autohide)
                if [[ -n "${3:-}" ]]; then
                    if [[ "$3" == "true" || "$3" == "false" ]]; then
                        sed -i "s/^PANEL_AUTOHIDE=.*/PANEL_AUTOHIDE=$3/" "$SETTINGS_FILE"
                        echo "Panel auto-hide set to: $3"
                        if [[ "$3" == "true" ]]; then
                            echo "Panel height will be ignored for layout calculations"
                        else
                            echo "Panel height (${PANEL_HEIGHT}px) will be reserved at top"
                        fi
                    else
                        echo "Error: Panel auto-hide must be 'true' or 'false'"
                        exit 1
                    fi
                else
                    echo "Panel auto-hide mode: ${PANEL_AUTOHIDE}"
                fi
                ;;
            show)
                echo "Current settings:"
                echo "  Gap: ${GAP}px"
                echo "  Panel height: ${PANEL_HEIGHT}px"
                echo "  Panel auto-hide: ${PANEL_AUTOHIDE}"
                echo "  Min window width: ${MIN_WIDTH}px"
                echo "  Min window height: ${MIN_HEIGHT}px"
                echo ""
                echo "Auto-layout preferences:"
                echo "  1 window:  ${AUTO_LAYOUT_1:-maximize}"
                echo "  2 windows: ${AUTO_LAYOUT_2:-equal}"
                echo "  3 windows: ${AUTO_LAYOUT_3:-main-two-side}"
                echo "  4 windows: ${AUTO_LAYOUT_4:-grid}"
                echo "  5 windows: ${AUTO_LAYOUT_5:-grid-wide-bottom}"
                echo ""
                echo "Configuration file: $SETTINGS_FILE"
                ;;
            *)
                echo "Configuration commands:"
                echo "  place-window config gap [SIZE]     Set or show gap size"
                echo "  place-window config panel [SIZE]   Set or show panel height"
                echo "  place-window config autohide [true/false]  Set panel auto-hide mode"
                echo "  place-window config show           Show all settings"
                ;;
        esac
        ;;
    help|--help|-h)
        cat << 'EOF'
Window Positioning Tool for Qubes OS dom0

Usage:
  place-window                    Interactive mode
  place-window ul|ur|ll|lr|c      Quick corner/center presets
  place-window left|right|top|bottom|maximize  Half-screen presets
  place-window auto               Auto-layout all visible windows
  place-window auto-config <N> [layout]  Configure auto-layout preferences
  place-window resize <direction> [pixels]  Simultaneous resize with adjacent windows
  place-window master <orientation>  Master-stack layouts
  place-window focus <direction>  Navigate between windows
  place-window watch <command>    Watch mode for automatic tiling
  place-window workspace <command>  Workspace-specific layout profiles
  place-window swap <mode>        Window position swapping
  place-window <X> <Y> <W> <H>    Custom geometry
  place-window ws <N>             Move to workspace N (0-based)
  place-window save <name>        Save current window position
  place-window load <name>        Load saved position
  place-window list               List all saved presets
  place-window monitors           Show monitor information
  place-window config <option>    Configuration commands
  place-window help               Show this help

Quick presets (with configurable gaps):
  ul - Upper left quarter    left - Left half
  ur - Upper right quarter   right - Right half
  ll - Lower left quarter    top - Top half
  lr - Lower right quarter   bottom - Bottom half
  c  - Center                maximize - Maximize with gaps

Auto-layout:
  place-window auto                   Arrange all visible windows automatically
  place-window auto-config show       Show current auto-layout preferences
  place-window auto-config 2 equal    Set 2-window layout to equal split
  
  Available auto-layouts:
    1 window:  maximize
    2 windows: equal, primary-secondary, secondary-primary
    3 windows: main-two-side, three-columns, center-sidebars
    4 windows: grid, main-three-side, three-top-bottom
    5 windows: center-corners, two-three-columns, grid-wide-bottom

Master-stack layouts (xpytile-inspired):
  place-window master vertical     Master left (60%), stack right (40%)
  place-window master horizontal   Master top (60%), stack bottom (40%)

Simultaneous resize (affects adjacent windows):
  place-window resize expand-right [pixels]   Expand right, shrink adjacent
  place-window resize shrink-right [pixels]   Shrink right, expand adjacent
  place-window resize expand-down [pixels]    Expand down, shrink adjacent
  place-window resize shrink-down [pixels]    Shrink down, expand adjacent

Focus navigation:
  place-window focus next/prev     Cycle through windows
  place-window focus up/down/left/right  Navigate geometrically

Watch mode (automatic tiling daemon):
  place-window watch start        Start automatic tiling daemon
  place-window watch stop         Stop the daemon
  place-window watch status       Check daemon status
  
  Watch mode monitors for new windows and automatically applies auto-layout
  when window count changes. Runs in background until stopped.

Workspace layout profiles:
  place-window workspace save <name>     Save current workspace layout
  place-window workspace load <name>     Load saved workspace layout
  place-window workspace list           List all saved profiles
  place-window workspace delete <name>   Delete a profile
  
  Workspace profiles save the position of all windows on the current
  workspace, allowing you to restore entire multi-window layouts.

Window position swapping:
  place-window swap drag          Drag-to-swap mode (click and drag)
  place-window swap interactive   Click two windows to swap positions
  
  Swap functionality allows you to exchange the positions and sizes
  of two windows to reorganize your tiled layout quickly.

Configuration commands:
  place-window config gap [SIZE]     Set or show gap size (default: 10px)
  place-window config panel [SIZE]   Set or show panel height (default: 32px)
  place-window config autohide [true/false]  Panel auto-hide mode
  place-window config show           Show all current settings

Examples:
  place-window                    # Interactive menu
  place-window auto               # Auto-arrange all visible windows
  place-window watch start        # Start automatic tiling daemon
  place-window workspace save work # Save current workspace layout
  place-window swap interactive    # Swap positions of two windows
  place-window master vertical    # Master-stack with master on left
  place-window resize expand-right 100  # Expand window right by 100px
  place-window focus right        # Focus window to the right
  place-window auto-config 2 primary-secondary  # 70/30 split for 2 windows
  place-window config gap 15      # Set 15px gaps around windows

Gap behavior:
  - All layouts maintain the configured gap around windows
  - Gaps are applied: left, right, top, bottom, and between windows
  - Custom coordinates ignore gaps for exact positioning
  - Simultaneous resize preserves gaps between adjacent windows

Configuration files:
  Settings: ~/.config/window-positioning/settings.conf
  Presets:  ~/.config/window-positioning/presets.conf

Multi-monitor support:
  place-window monitors           Show detected monitors and layout areas
  
  Multi-monitor behavior:
  • Windows positioned within their current monitor boundaries
  • Auto-layout groups and arranges windows per monitor
  • Panel height applied only to primary monitor (usually leftmost)
  • All presets (ul, ur, etc.) work within the target monitor

Advanced Features (inspired by xpytile):
  • Simultaneous resize of adjacent windows
  • Master-stack layouts with configurable ratios
  • Geometric focus navigation
  • Auto-layout based on window count
  • Multi-monitor aware positioning
EOF
        ;;
    *[0-9]*)
        # Custom geometry (4 numbers)
        if [[ "$#" -ne 4 ]]; then
            echo "Error: Custom geometry requires 4 numbers: X Y Width Height"
            exit 1
        fi
        id=$(pick_window)
        apply_geometry "$id" "$1" "$2" "$3" "$4"
        ;;
    *)
        # Try as saved preset
        id=$(pick_window)
        apply_preset "$1" "$id"
        ;;
esac